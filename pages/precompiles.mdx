import { Callout } from "nextra/components";

# Precompiled Contracts

Sei precompiles are smart contracts built directly into the Sei blockchain. They enable users
and developers to interact with native Sei functions from the EVM RPC. This section will go over
the various precompiles on Sei and provide examples on how to use them.

## Sei Precompiles

Below is a list of the precompiled contracts available on Sei.

### CosmWasm

**Address**: `0x0000000000000000000000000000000000001002`

This precompile serves as an interface to the CosmWasm module, enabling EVM smart contracts to interact with CosmWasm contracts directly.

<Callout type="info">
  View the CosmWasm precompile source code and the contract ABI
  [here](https://github.com/sei-protocol/sei-chain/tree/evm/precompiles/wasmd).
</Callout>

### Staking

**Address**: `0x0000000000000000000000000000000000001005`

This precompile allows EVM contracts to interact with Sei's staking module, enabling functionalities such as delegating tokens, querying validators, and more.

<Callout type="info">
  View the Staking precompile source code and the contract ABI
  [here](https://github.com/sei-protocol/sei-chain/tree/evm/precompiles/staking).
</Callout>

### Governance

**Address**: `0x0000000000000000000000000000000000001006`

This precompile enables participation in Sei's governance process through the EVM, allowing EVM users and contracts to submit proposals, vote, and query governance information.

<Callout type="info">
  View the Governance precompile source code and the contract ABI
  [here](https://github.com/sei-protocol/sei-chain/tree/evm/precompiles/gov).
</Callout>

## Example Usage

These precompiles can be used like any standard smart contract on the EVM. For example, using [Ethers](https://docs.ethers.org/v6/), you can query and execute actions on a CosmWasm contract as follows:

```typescript copy
import { ethers, toUtf8Bytes, toUtf8String } from "ethers";

// Counter contract address (used for testing on arctic-1)
const COUNTER_CONTRACT_ADDRESS =
  "sei14hj2tavq8fpesdwxxcu44rty3hh90vhujrvcmstl4zr3txmfvw9sh9m79m";

// Wasm precompile address
const WASM_PRECOMPILE_ADDRESS = "0x0000000000000000000000000000000000001002";

// The contract ABI (fragments we care about)
const abi = [
  {
    inputs: [
      {
        internalType: "string",
        name: "contractAddress",
        type: "string",
      },
      {
        internalType: "bytes",
        name: "msg",
        type: "bytes",
      },
      {
        internalType: "bytes",
        name: "coins",
        type: "bytes",
      },
    ],
    name: "execute",
    outputs: [
      {
        internalType: "bytes",
        name: "response",
        type: "bytes",
      },
    ],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "string",
        name: "contractAddress",
        type: "string",
      },
      {
        internalType: "bytes",
        name: "req",
        type: "bytes",
      },
    ],
    name: "query",
    outputs: [
      {
        internalType: "bytes",
        name: "response",
        type: "bytes",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
];

// Using MetaMask as the signer and provider
const provider = new ethers.BrowserProvider(window.ethereum);
const signer = await provider.getSigner();

// Create a contract with the signer
const contract = new ethers.Contract(
  WASM_PRECOMPILE_ADDRESS,
  WASM_PRECOMPILE_ABI,
  signer
);

// Simple query to get the count on the counter contract
const queryJSON = { get_count: {} };
const response = await contract.query(
  COUNTER_CONTRACT_ADDRESS,
  toUtf8Bytes(JSON.stringify(queryJSON))
);
const stringResponse = toUtf8String(test);
console.log(stringResponse);

// Simple execute message to increment the count on the contract
const executeMsg = { increment: {} };
const response = await contract.execute(
  COUNTER_CONTRACT_ADDRESS,
  toUtf8Bytes(JSON.stringify(executeMsg)),
  toUtf8Bytes(JSON.stringify([])) // Used for sending funds if needed
);
// Wait for the transaction to be confirmed
await response.wait();
console.log(response);
```
