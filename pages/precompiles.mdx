import { Callout } from "nextra/components";

# Precompiled Contracts

Sei precompiles are smart contracts built directly into the Sei blockchain. They enable users
and developers to interact with native Sei functions from the EVM RPC. This section will go over
the various precompiles on Sei and provide examples on how to use them.

## Sei Precompiles

Below is a list of the precompiled contracts available on Sei.

### CosmWasm

**Address**: `0x0000000000000000000000000000000000001002`

This precompile serves as an interface to the CosmWasm module, enabling EVM smart contracts to interact with CosmWasm contracts directly.

#### Functions

- `instantiate`: Instantiates a new CosmWasm contract

  ```solidity
  function instantiate(
      uint64 codeID,
      string memory admin,
      bytes memory msg,
      string memory label,
      bytes memory coins
  ) external returns (string memory contractAddr, bytes memory data);
  ```

- `execute`: Sends a message to a CosmWasm contract for execution

  ```solidity
  function execute(
      string memory contractAddress,
      bytes memory msg,
      bytes memory coins
  ) external returns (bytes memory response);
  ```

- `query`: Queries a CosmWasm contract state
  ```solidity
  function execute(
      string memory contractAddress,
      bytes memory msg,
      bytes memory coins
  ) external returns (bytes memory response);
  ```

<Callout type="info">
  View the CosmWasm precompile source code and the contract ABI
  [here](https://github.com/sei-protocol/sei-chain/tree/evm/precompiles/wasmd).
</Callout>

### Staking

**Address**: `0x0000000000000000000000000000000000001005`

This precompile allows EVM contracts to interact with Sei's staking module, enabling functionalities such as delegating tokens, querying validators, and more.

#### Functions

- `delegate`: Allows a user to delegate a specified amount of tokens to a validator

  ```solidity
  function delegate(
      string memory valAddress,
      uint256 amount
  ) external returns (bool success);
  ```

- `redelegate`: Enables the redelegation of tokens from one validator to another

  ```solidity
  function redelegate(
      string memory srcAddress,
      string memory dstAddress,
      uint256 amount
  ) external returns (bool success);
  ```

- `undelegate`: Provides the functionality for a user to withdraw a specified amount of tokens from a validator
  ```solidity
  function undelegate(
      string memory valAddress,
      uint256 amount
  ) external returns (bool success);
  ```

<Callout type="info">
  View the Staking precompile source code and the contract ABI
  [here](https://github.com/sei-protocol/sei-chain/tree/evm/precompiles/staking).
</Callout>

### Governance

**Address**: `0x0000000000000000000000000000000000001006`

This precompile enables participation in Sei's governance process through the EVM, allowing EVM users and contracts to submit proposals, vote, and query governance information.

#### Functions

- `vote`: Allows a user to cast a vote on a governance proposal

  ```solidity
    function vote(
        uint64 proposalID,
        int32 option
    ) external returns (bool success);
  ```

- `deposit`: Enables a user to deposit tokens into a governance proposal
  ```solidity
    function deposit(
        uint64 proposalID,
        uint256 amount
    ) external returns (bool success);
  ```

<Callout type="info">
  View the Governance precompile source code and the contract ABI
  [here](https://github.com/sei-protocol/sei-chain/tree/evm/precompiles/gov).
</Callout>

## Example Usage

These precompiles can be used like any standard smart contract on the EVM. For example, using [ethers.js](https://docs.ethers.org/v6/), you can query and execute actions on a CosmWasm contract as follows:

### Setup

To install `ethers.js`, run the following command in your project directory terminal:

```bash copy
npm install ethers
```

Next, you'll need to use one of the precompiles listed above. In this example, we're going to be using the Wasm precompile:

```typescript copy
// Wasm precompile address
const WASM_PRECOMPILE_ADDRESS = "0x0000000000000000000000000000000000001002";

// The precompiled contract ABI (fragments we care about)
// View the entire ABI here: https://github.com/sei-protocol/sei-chain/tree/evm/precompiles/wasmd
const WASM_PRECOMPILE_ABI = [
  {
    inputs: [
      {
        internalType: "string",
        name: "contractAddress",
        type: "string",
      },
      {
        internalType: "bytes",
        name: "msg",
        type: "bytes",
      },
      {
        internalType: "bytes",
        name: "coins",
        type: "bytes",
      },
    ],
    name: "execute",
    outputs: [
      {
        internalType: "bytes",
        name: "response",
        type: "bytes",
      },
    ],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "string",
        name: "contractAddress",
        type: "string",
      },
      {
        internalType: "bytes",
        name: "req",
        type: "bytes",
      },
    ],
    name: "query",
    outputs: [
      {
        internalType: "bytes",
        name: "response",
        type: "bytes",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
];
```

### Using the contract

Next, we'll set up a provider and contract to interact with the blockchain:

```typescript copy
import { ethers, toUtf8Bytes, toUtf8String } from "ethers";

// Using MetaMask as the signer and provider
const provider = new ethers.BrowserProvider(window.ethereum);
const signer = await provider.getSigner();

// Create a contract with the signer
const contract = new ethers.Contract(
  WASM_PRECOMPILE_ADDRESS,
  WASM_PRECOMPILE_ABI,
  signer
);
```

<Callout type="info">
  If using MetaMask, the wallet must be switched to the Sei EVM Devnet chain.
  Learn how to import the Sei EVM Devnet chain [here](/setting-up-a-wallet).
</Callout>

#### Querying & Executing a CosmWasm Contraact

Once you have the contract, you can query and execute messages to any CosmWasm smart contract.

```typescript
// Counter CosmWasm contract (used for testing on arctic-1)
// Replace with your contract as needed
const COUNTER_CONTRACT_ADDRESS =
  "sei14hj2tavq8fpesdwxxcu44rty3hh90vhujrvcmstl4zr3txmfvw9sh9m79m";

// Query to get the count on the counter contract
const queryMsg = { get_count: {} };
const queryResponse = await contract.query(
  COUNTER_CONTRACT_ADDRESS,
  toUtf8Bytes(JSON.stringify(queryMsg))
);
console.log(toUtf8String(queryResponse));

// Execute message to increment the count on the contract
const executeMsg = { increment: {} };
const executeResponse = await contract.execute(
  COUNTER_CONTRACT_ADDRESS,
  toUtf8Bytes(JSON.stringify(executeMsg)),
  toUtf8Bytes(JSON.stringify([])) // Used for sending funds if needed
);
// Wait for the transaction to be confirmed
await executeResponse.wait();
console.log(executeResponse);
```
