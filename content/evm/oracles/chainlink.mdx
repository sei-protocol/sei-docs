---
title: 'Chainlink Data Streams'
description: 'Complete guide to integrating Chainlink Data Streams with Sei blockchain for off-chain data fetching and on-chain verification'
---

import { Callout } from 'nextra/components';

## Introduction

**Chainlink** is a decentralized oracle network that enables smart contracts to securely access off-chain data feeds, web APIs, and traditional bank payments. **Data Streams** is Chainlink's next-generation data infrastructure that provides ultra-low latency, high-frequency market data with cryptographic proof of data integrity.

Data Streams delivers market data with sub-second latency and comes with cryptographic reports that can be verified on-chain, ensuring data authenticity and preventing manipulation.

## What You'll Learn

In this tutorial, you will:

1. Deploy a contract and configure it to access data streams on Sei
2. Set up a Node.js project to fetch off-chain data from Chainlink Data Streams
3. Verify the authenticity of the data on-chain using your deployed verifier contract
4. Understand the complete flow from off-chain data retrieval to on-chain verification

## Prerequisites

Before starting, ensure you have the following installed and set up:

- **Node.js** (version 16 or higher)
- **npm** or **yarn** package manager
- **Hardhat** for smart contract deployment
- Basic knowledge of **JavaScript/TypeScript** and **Solidity**

### Sei Verifier Addresses

- **Testnet**: `0x60fAa7faC949aF392DFc858F5d97E3EEfa07E9EB`
- **Mainnet**: `0x60fAa7faC949aF392DFc858F5d97E3EEfa07E9EB`

## Setup

### 1. Initialize Your Project

```bash
mkdir chainlink-data-streams-tutorial
cd chainlink-data-streams-tutorial
npm init -y
```

### 2. Install Dependencies

```bash
npm install ethers dotenv @chainlink/contracts
npm install --save-dev hardhat @nomicfoundation/hardhat-toolbox typescript
```

### 3. Initialize Hardhat

```bash
npx hardhat init
```

Select "Create a TypeScript project" when prompted.

### 4. Environment Configuration

Create a `.env` file in your project root:

```env
PRIVATE_KEY=your_wallet_private_key
SEI_TESTNET_RPC=https://evm-rpc-testnet.sei-apis.com
SEI_MAINNET_RPC=https://evm-rpc.sei-apis.com
CHAINLINK_CLIENT_ID=your_chainlink_client_id
CHAINLINK_CLIENT_SECRET=your_chainlink_client_secret
```

## Code Implementation

### 1. Smart Contract - Data Streams Verifier

Create `contracts/DataStreamsVerifier.sol`:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import {Common} from "@chainlink/contracts/src/v0.8/llo-feeds/libraries/Common.sol";
import {IVerifierFeeManager} from "@chainlink/contracts/src/v0.8/llo-feeds/v0.3.0/interfaces/IVerifierFeeManager.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {SafeERC20} from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";

using SafeERC20 for IERC20;

/**
 * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE FOR DEMONSTRATION PURPOSES.
 * DO NOT USE THIS CODE IN PRODUCTION.
 *
 *  This contract can verify Chainlink Data Streams reports onchain and pay
 *  the verification fee in LINK (when required).
 */

// ────────────────────────────────────────────────────────────────────────────
//  Interfaces
// ────────────────────────────────────────────────────────────────────────────

interface IVerifierProxy {
  /**
   * @notice Route a report to the correct verifier and (optionally) bill fees.
   * @param payload           Full report payload (header + signed report).
   * @param parameterPayload  ABI-encoded fee metadata.
   */
  function verify(
    bytes calldata payload,
    bytes calldata parameterPayload
  ) external payable returns (bytes memory verifierResponse);

  function verifyBulk(
    bytes[] calldata payloads,
    bytes calldata parameterPayload
  ) external payable returns (bytes[] memory verifiedReports);

  function s_feeManager() external view returns (IVerifierFeeManager);
}

interface IFeeManager {
  /**
   * @return fee, reward, totalDiscount
   */
  function getFeeAndReward(
    address subscriber,
    bytes memory unverifiedReport,
    address quoteAddress
  ) external returns (Common.Asset memory, Common.Asset memory, uint256);

  function i_linkAddress() external view returns (address);

  function i_nativeAddress() external view returns (address);

  function i_rewardManager() external view returns (address);
}

// ────────────────────────────────────────────────────────────────────────────
//  Contract
// ────────────────────────────────────────────────────────────────────────────

/**
 * @dev This contract implements functionality to verify Data Streams reports from
 * the Data Streams API, with payment in LINK tokens.
 */
contract ClientReportsVerifier {
  // ----------------- Errors -----------------
  error NothingToWithdraw();
  error NotOwner(address caller);
  error InvalidReportVersion(uint16 version);

  // ----------------- Report schemas -----------------
  // More info: https://docs.chain.link/data-streams/reference/report-schema-v3
  /**
   * @dev Data Streams report schema v3 (crypto streams).
   *      Prices, bids and asks use 8 or 18 decimals depending on the stream.
   */
  struct ReportV3 {
    bytes32 feedId;
    uint32 validFromTimestamp;
    uint32 observationsTimestamp;
    uint192 nativeFee;
    uint192 linkFee;
    uint32 expiresAt;
    int192 price;
    int192 bid;
    int192 ask;
  }

  /**
   * @dev Data Streams report schema v8 (RWA streams).
   */
  struct ReportV8 {
    bytes32 feedId;
    uint32 validFromTimestamp;
    uint32 observationsTimestamp;
    uint192 nativeFee;
    uint192 linkFee;
    uint32 expiresAt;
    uint64 lastUpdateTimestamp;
    int192 midPrice;
    uint32 marketStatus;
  }

  // ----------------- Storage -----------------
  IVerifierProxy public immutable i_verifierProxy;
  address private immutable i_owner;

  int192 public lastDecodedPrice;

  // ----------------- Events -----------------
  event DecodedPrice(int192 price);

  // ----------------- Constructor / modifier -----------------
  /**
   * @param _verifierProxy Address of the VerifierProxy on the target network.
   *        Addresses: https://docs.chain.link/data-streams/crypto-streams
   */
  constructor(
    address _verifierProxy
  ) {
    i_owner = msg.sender;
    i_verifierProxy = IVerifierProxy(_verifierProxy);
  }

  modifier onlyOwner() {
    if (msg.sender != i_owner) revert NotOwner(msg.sender);
    _;
  }

  // ----------------- Public API -----------------

  /**
   * @notice Verify a Data Streams report (schema v3 or v8).
   *
   * @dev Steps:
   *  1. Decode the unverified report to get `reportData`.
   *  2. Read the first two bytes → schema version (`0x0003` or `0x0008`).
   *     - Revert if the version is unsupported.
   *  3. Fee handling:
   *     - Query `s_feeManager()` on the proxy.
   *       – Non-zero → quote the fee, approve the RewardManager,
   *         ABI-encode the fee token address for `verify()`.
   *       – Zero     → no FeeManager; skip quoting/approval and pass `""`.
   *  4. Call `VerifierProxy.verify()`.
   *  5. Decode the verified report into the correct struct and emit the price.
   *
   *  @param unverifiedReport Full payload returned by Streams Direct.
   *  @custom:reverts InvalidReportVersion when schema ≠ v3/v8.
   */
  function verifyReport(
    bytes memory unverifiedReport
  ) external {
    // ─── 1. & 2. Extract reportData and schema version ──
    (, bytes memory reportData) = abi.decode(unverifiedReport, (bytes32[3], bytes));

    uint16 reportVersion = (uint16(uint8(reportData[0])) << 8) | uint16(uint8(reportData[1]));
    if (reportVersion != 3 && reportVersion != 8) {
      revert InvalidReportVersion(reportVersion);
    }

    // ─── 3. Fee handling ──
    IFeeManager feeManager = IFeeManager(address(i_verifierProxy.s_feeManager()));

    bytes memory parameterPayload;
    if (address(feeManager) != address(0)) {
      // FeeManager exists — always quote & approve
      address feeToken = feeManager.i_linkAddress();

      (Common.Asset memory fee,,) = feeManager.getFeeAndReward(address(this), reportData, feeToken);

      IERC20(feeToken).approve(feeManager.i_rewardManager(), fee.amount);
      parameterPayload = abi.encode(feeToken);
    } else {
      // No FeeManager deployed on this chain
      parameterPayload = bytes("");
    }

    // ─── 4. Verify through the proxy ──
    bytes memory verified = i_verifierProxy.verify(unverifiedReport, parameterPayload);

    // ─── 5. Decode & store price ──
    if (reportVersion == 3) {
      int192 price = abi.decode(verified, (ReportV3)).price;
      lastDecodedPrice = price;
      emit DecodedPrice(price);
    } else {
      int192 price = abi.decode(verified, (ReportV8)).midPrice;
      lastDecodedPrice = price;
      emit DecodedPrice(price);
    }
  }

  /**
   * @notice Withdraw all balance of an ERC-20 token held by this contract.
   * @param _beneficiary Address that receives the tokens.
   * @param _token       ERC-20 token address.
   */
  function withdrawToken(
    address _beneficiary,
    address _token
  ) external onlyOwner {
    uint256 amount = IERC20(_token).balanceOf(address(this));
    if (amount == 0) revert NothingToWithdraw();
    IERC20(_token).safeTransfer(_beneficiary, amount);
  }
}
```

### 2. TypeScript Client for Off-chain Data Fetching

Create `dataStreamsClient.ts`:

```typescript
import { ethers } from 'ethers';
import dotenv from 'dotenv';

dotenv.config();

interface AuthResponse {
  access_token: string;
  token_type: string;
  expires_in: number;
}

interface StreamsResponse {
  report: string;
  reportContext: string[];
}

class DataStreamsClient {
  private baseUrl = 'https://api.testnet-dataengine.chain.link';
  private accessToken: string | null = null;
  private tokenExpiry: number = 0;

  constructor(
    private clientId: string,
    private clientSecret: string
  ) {}

  private async authenticate(): Promise<void> {
    if (this.accessToken && Date.now() < this.tokenExpiry) {
      return; // Token is still valid
    }

    const authUrl = `${this.baseUrl}/auth/token`;
    const credentials = Buffer.from(`${this.clientId}:${this.clientSecret}`).toString('base64');

    const response = await fetch(authUrl, {
      method: 'POST',
      headers: {
        Authorization: `Basic ${credentials}`,
        'Content-Type': 'application/x-www-form-urlencoded'
      },
      body: 'grant_type=client_credentials'
    });

    if (!response.ok) {
      throw new Error(`Authentication failed: ${response.statusText}`);
    }

    const authData: AuthResponse = await response.json();
    this.accessToken = authData.access_token;
    this.tokenExpiry = Date.now() + authData.expires_in * 1000 - 60000; // Refresh 1 minute early
  }

  async fetchDataStreamsReport(feedIds: string[]): Promise<StreamsResponse> {
    await this.authenticate();

    const streamsUrl = `${this.baseUrl}/streams`;
    const queryParams = feedIds.map((id) => `feedIds=${id}`).join('&');

    const response = await fetch(`${streamsUrl}?${queryParams}`, {
      method: 'GET',
      headers: {
        Authorization: `Bearer ${this.accessToken}`,
        Accept: 'application/json'
      }
    });

    if (!response.ok) {
      throw new Error(`Failed to fetch streams data: ${response.statusText}`);
    }

    return response.json();
  }
}

// Example usage
async function main() {
  const client = new DataStreamsClient(process.env.CHAINLINK_CLIENT_ID!, process.env.CHAINLINK_CLIENT_SECRET!);

  try {
    // Example feed ID for SEI/USD (replace with actual feed ID)
    const feedIds = ['0x0003487e79423ea3c34f4edfc8bb112b0d0fbe054906644912b04bd5a3c6243b'];

    const streamData = await client.fetchDataStreamsReport(feedIds);
    console.log('Fetched Data Streams Report:', streamData);

    // Verify on-chain (implementation below)
    await verifyReportOnChain(streamData);
  } catch (error) {
    console.error('Error:', error);
  }
}

async function verifyReportOnChain(streamData: StreamsResponse) {
  const provider = new ethers.JsonRpcProvider(process.env.SEI_TESTNET_RPC);
  const wallet = new ethers.Wallet(process.env.PRIVATE_KEY!, provider);

  // Contract ABI (updated for new contract)
  const contractABI = ['function verifyReport(bytes memory unverifiedReport) external', 'function lastDecodedPrice() external view returns (int192)', 'function withdrawToken(address _beneficiary, address _token) external', 'event DecodedPrice(int192 price)'];

  // Replace with your deployed contract address
  const contractAddress = 'YOUR_DEPLOYED_CONTRACT_ADDRESS';
  const contract = new ethers.Contract(contractAddress, contractABI, wallet);

  try {
    // Convert hex string to bytes
    const reportBytes = streamData.report;

    // Verify the report on-chain using the new function
    const tx = await contract.verifyReport(reportBytes);
    console.log('Transaction hash:', tx.hash);

    const receipt = await tx.wait();
    console.log('Report verified on-chain! Block:', receipt.blockNumber);

    // Get the latest decoded price
    const lastPrice = await contract.lastDecodedPrice();
    console.log('Latest decoded price:', lastPrice.toString());

    // Listen for the DecodedPrice event
    contract.on('DecodedPrice', (price) => {
      console.log(`Price decoded: ${price.toString()}`);
    });
  } catch (error) {
    console.error('Error verifying report on-chain:', error);
  }
}

export { DataStreamsClient };

if (require.main === module) {
  main();
}
```

### 3. Hardhat Configuration

Update `hardhat.config.ts`:

```typescript
import { HardhatUserConfig } from 'hardhat/config';
import '@nomicfoundation/hardhat-toolbox';
import dotenv from 'dotenv';

dotenv.config();

const config: HardhatUserConfig = {
  solidity: '0.8.19',
  networks: {
    seiTestnet: {
      url: process.env.SEI_TESTNET_RPC,
      accounts: [process.env.PRIVATE_KEY!],
      chainId: 1328
    },
    seiMainnet: {
      url: process.env.SEI_MAINNET_RPC,
      accounts: [process.env.PRIVATE_KEY!],
      chainId: 1329
    }
  }
};

export default config;
```

### 4. Deployment Script

Create `scripts/deploy.ts`:

```typescript
import { ethers } from 'hardhat';

async function main() {
  const verifierAddress = '0x60fAa7faC949aF392DFc858F5d97E3EEfa07E9EB';

  const DataStreamsVerifier = await ethers.getContractFactory('DataStreamsVerifier');
  const verifier = await DataStreamsVerifier.deploy(verifierAddress);

  await verifier.waitForDeployment();

  console.log('DataStreamsVerifier deployed to:', await verifier.getAddress());
}

main().catch((error) => {
  console.error(error);
  process.exitCode = 1;
});
```

## Deployment

### 1. Compile the Contract

```bash
npx hardhat compile
```

### 2. Deploy to Sei Testnet

```bash
npx hardhat run scripts/deploy.ts --network seiTestnet
```

### 3. Deploy to Sei Mainnet

```bash
npx hardhat run scripts/deploy.ts --network seiMainnet
```

Save the deployed contract address from the output and update your `dataStreamsClient.ts` file.

## Running the Client

To run the TypeScript client and fetch/verify data:

```bash
ts-node dataStreamsClient.ts
```

## Expected Output

### Off-chain Data Fetching

```bash
npx ts-node src/dataStreamsClient.ts
Fetched Data Streams Report: {
  report: "0x0006f4240e98c4bb6ac24d0b1e3a5f1f8a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d7e8f9a0b1c2d3e4f5a6b7c8d9e0f1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d...",
  reportContext: []
}
```

### On-chain Verification

```bash
Transaction hash: 0xabc123def456ghi789jkl012mno345pqr678stu901vwx234yz567890abcdef123
Report verified on-chain! Block: 1234567
Latest decoded price: 2345678900000000000000
Price decoded: 2345678900000000000000
```

## Additional Resources

For more advanced features and detailed documentation, explore:

- [Chainlink Data Streams Documentation](https://docs.chain.link/data-streams) - Complete API reference and guides
- [Sei Documentation](https://docs.sei.io/) - Sei official docs and resources
