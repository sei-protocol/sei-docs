---
title: 'WebSockets & Subscriptions'
description: 'Design robust WS consumers on Sei: caps, heartbeats, reconnect, replay, and best practices.'
keywords: ['websocket', 'subscriptions', 'newHeads', 'logs', 'reliability', 'sei evm']
---

import { Callout } from 'nextra/components';
import { TroubleshootingTable } from '../../mdx-components';

# WebSockets & Subscriptions

Real-time event streams via WebSocket subscriptions (`eth_subscribe`) for `newHeads`, `logs`, and `newPendingTransactions`.

## Configuration Limits

| Parameter                    | Default   | Description                                                         |
| :--------------------------- | :-------- | :------------------------------------------------------------------ |
| `max_subscriptions_new_head` | 10,000    | Maximum concurrent `newHeads` subscriptions per node                |
| Subscription buffer          | 10 blocks | Internal buffer per subscription; slow consumers trigger disconnect |
| Connection capacity          | 100       | Maximum subscriptions per connection (all types combined)           |

<Callout type="warning">Nodes enforce `max_subscriptions_new_head` globally. When the limit is reached, new `eth_subscribe('newHeads')` calls return `no new subscription can be created`.</Callout>

## Subscription Types

<KeyValueTable
  rows={[
    ['`newHeads`', 'Streams canonical block headers. Default cap: `max_subscriptions_new_head = 5000`. Use for lightweight UI updates.'],
    ['`logs`', 'Filters logs by address/topics across live blocks. Obeys `max_blocks_for_log` and inherits Cosmos rate limits.'],
    ['`newPendingTransactions`', 'Surface pending transactions from the mempool. Sensitive to `mempool.cache_size` pressure; avoid on public endpoints.']
  ]}
/>

## Connection Management

<CardGrid
  items={[
    {
      title: 'Heartbeat loop',
      description: 'Send `eth_subscribe` keep-alives or lightweight RPC calls every ~20s to keep proxies from reclaiming idle sockets.',
      href: '#subscription-types'
    },
    {
      title: 'Backoff strategy',
      description: 'Reconnect with exponential backoff when the node drops the socket (e.g., capacity reached). Avoid thundering herds.',
      href: '#troubleshooting'
    },
    {
      title: 'Replay window',
      description: 'Persist the last seen block number and resubscribe with a `fromBlock` when you reconnect to cover missed events.',
      href: '#log-replay'
    }
  ]}
/>

## Replay & Gap Handling

When a WebSocket disconnects:

1. **Track last processed block** (store `block.number` and `block.hash`)
2. **On reconnect**, fetch current head via HTTP `eth_blockNumber`
3. **Backfill gaps** using `eth_getLogs` with block ranges â‰¤ 2,000 blocks (respects `MaxBlocksForLog`)
4. **Deduplicate** by `(transactionHash, logIndex)` to handle overlaps
5. **Resume** subscription from current head

```typescript copy
// Gap backfill pattern
async function backfillGap(fromBlock: number, toBlock: number) {
  const logs = await httpProvider.send('eth_getLogs', [
    {
      fromBlock: `0x${fromBlock.toString(16)}`,
      toBlock: `0x${toBlock.toString(16)}`,
      address: contractAddress
    }
  ]);

  // Deduplicate and process
  const seen = new Set();
  for (const log of logs) {
    const key = `${log.transactionHash}-${log.logIndex}`;
    if (!seen.has(key)) {
      seen.add(key);
      processLog(log);
    }
  }
}
```

## Best Practices

- **One subscription per topic** - Fan out internally rather than creating duplicate `newHeads` subscriptions
- **Monitor buffer health** - Track dropped subscriptions (channel closure) as a signal of slow consumption
- **Hybrid approach** - Use WebSocket for real-time updates, HTTP for historical queries and backfills
- **Avoid trace/sim during WS handling** - Offload heavy `debug_traceTransaction` calls to background workers

## Troubleshooting

<TroubleshootingTable
  rows={[
    ['no new subscription can be created', 'Node newHeads limit (10,000) reached', 'Check node config for max_subscriptions_new_head; reuse existing subscriptions or request limit increase.'],
    ['Subscription closed unexpectedly', 'Consumer not draining buffer fast enough', 'Increase processing speed or buffer size; slow consumers trigger auto-close.'],
    ['Missing blocks after reconnect', 'Gap in stream during disconnect', 'Backfill using eth_getLogs with last processed block as fromBlock.'],
    ['Connection drops frequently', 'Network instability or missing heartbeats', 'Implement ping/pong heartbeat every 30s; reconnect with exponential backoff.']
  ]}
/>

## References

- WebSocket implementation: [github.com/sei-protocol/sei-chain/evmrpc/subscribe.go](https://github.com/sei-protocol/sei-chain/blob/main/evmrpc/subscribe.go)
- Configuration: [EVM RPC Config](/node/evmrpc-config)
