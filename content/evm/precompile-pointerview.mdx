---
title: 'PointerView Precompile'
description: 'Query pointer state and ownership between CW and EVM.'
keywords: ['pointerview', 'interop', 'precompile', 'sei evm']
---

import { Callout } from 'nextra/components';
import { FunctionList, TroubleshootingTable } from '../../mdx-components';

# PointerView Precompile

**Address:** `0x000000000000000000000000000000000000100A`

PointerView is the read-only counterpart to Pointer. Use it to resolve canonical EVM contracts, confirm version numbers, and avoid duplicate registrations. It mirrors on-chain state without emitting events.

<Callout type="info">PointerView returns the latest mapping even if events were missed. Always query it after pointer writes to verify success.</Callout>

## Functions

<FunctionList
  items={[
    {
      name: 'getCW20Pointer',
      signature: 'function getCW20Pointer(string cwAddr) view returns (address addr, uint16 version, bool exists)',
      description: 'Fetch the ERC-20 pointer for a CW20 contract, with version and existence flag.'
    },
    {
      name: 'getCW721Pointer',
      signature: 'function getCW721Pointer(string cwAddr) view returns (address addr, uint16 version, bool exists)',
      description: 'Resolve the ERC-721 pointer that mirrors the CW721 collection.'
    },
    {
      name: 'getCW1155Pointer',
      signature: 'function getCW1155Pointer(string cwAddr) view returns (address addr, uint16 version, bool exists)',
      description: 'Return ERC-1155 pointer information for the CW1155 contract.'
    },
    {
      name: 'getNativePointer',
      signature: 'function getNativePointer(string token) view returns (address addr, uint16 version, bool exists)',
      description: 'Look up the pointer contract for a native denom (e.g., "usei").'
    }
  ]}
/>

<details>
<summary>Full Solidity Interface</summary>

```solidity copy
interface IPointerViewPrecompile {
  function getCW20Pointer(string memory cwAddr) external view returns (address addr, uint16 version, bool exists);
  function getCW721Pointer(string memory cwAddr) external view returns (address addr, uint16 version, bool exists);
  function getCW1155Pointer(string memory cwAddr) external view returns (address addr, uint16 version, bool exists);
  function getNativePointer(string memory token) external view returns (address addr, uint16 version, bool exists);
}
```

</details>

## Usage Patterns

- **Post-registration verification** - After calling Pointer, immediately query PointerView to confirm the mapping, record the pointer address, and capture the version number in your registry.
- **Contract lookups** - Smart contracts should query PointerView before interacting with a pointer to avoid hard-coded addresses. Cache the result per block to reduce RPC calls.
- **Indexing reconciliation** - Indexers replay Pointer events but treat PointerView as the authoritative source. Nightly jobs compare stored mappings with PointerView responses.
- **Frontend display** - Wallets and explorers call PointerView to display the source CW contract or native denom associated with an EVM asset.

## Example: Guarding Calls With PointerView

```typescript copy
import { ethers } from 'ethers';

const POINTER_VIEW = '0x000000000000000000000000000000000000100A';
const ABI = ['function getCW20Pointer(string cwAddr) view returns (address addr, uint16 version, bool exists)', 'function getNativePointer(string token) view returns (address addr, uint16 version, bool exists)'];

const provider = new ethers.JsonRpcProvider('https://evm-rpc.sei-apis.com');
const pointerView = new ethers.Contract(POINTER_VIEW, ABI, provider);

export async function resolveCW20(cwAddr: string) {
  const [pointer, version, exists] = await pointerView.getCW20Pointer(cwAddr);
  if (!exists) {
    throw new Error('Pointer not registered');
  }
  return { pointer, version };
}

export async function resolveNative(denom: string) {
  const [address, version, exists] = await pointerView.getNativePointer(denom);
  return exists ? { address, version } : null;
}
```

## Operations & Monitoring

- Query pointer view endpoints from automation scripts before initiating migrations or pointer-dependent transactions.
- Record pointer versions and alert if they change unexpectedly; version increments indicate a re-registration or contract upgrade.
- Expose PointerView queries in health checks to confirm RPC endpoints are returning consistent data.
- When indexers miss events, use PointerView as the recovery source and backfill historical state from its responses.

## Notes

- PointerView is read-only; use the Pointer precompile to create or update mappings.
- Responses mirror on-chain state and require no fee; cache results responsibly to avoid unnecessary RPC load.
- Use PointerView to confirm pointer ownership before invoking Solo, Bank, or other precompiles that rely on pointer addresses.
- `exists` returning `false` signals a missing mapping; treat `address(0)` with `exists=true` as an invalid state and escalate.

## Troubleshooting

<TroubleshootingTable
  rows={[
    ['address(0) returned', 'Pointer not registered for the specified contract/denom.', 'Confirm the pointer was registered, or trigger registration via the Pointer precompile.'],
    ['exists = false', 'Pointer record never created or was removed in future versions.', 'Validate mapping history, re-run registration if governance approves.'],
    ['Version mismatch across nodes', 'RPC endpoints serving stale data.', 'Compare against a trusted node, clear CDN caches, and restart affected RPC servers.']
  ]}
/>

## Related Docs

- [Pointer Precompile](/evm/precompile-pointer) - Write surface for registering pointers.
- [Pointers Deep Dive](/evm/pointers-deep-dive) - Architecture patterns, migrations, and operations.
- [Solo Precompile](/evm/precompile-solo) - Consumes PointerView data during asset migrations.
