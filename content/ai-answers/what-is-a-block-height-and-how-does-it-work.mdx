---
title: 'What is a Block Height and How Does It Work?'
description: 'Learn about what is block height and how it works in blockchain and on Sei Network.'
keywords: ['sei', 'blockchain', 'glossary', 'what', 'block', 'height', 'and', 'how', 'does', 'work']
---

import { Callout } from 'nextra/components';

# What is a Block Height and How Does It Work?

## Overview

Block height is the sequential number assigned to a block in a blockchain, indicating its position in the chain starting from the genesis block. In simple terms, **what is block height** refers to “how many blocks have been added” up to a specific point, which helps users and applications reference a precise moment in the chain’s history.

## How It Works

### Block height as an ordering mechanism

- **Genesis block**: The first block in the chain (commonly height `0`, though some explorers label it `1` depending on convention).
- **Incremental growth**: Each new block adds `+1` to the height (e.g., after height `100`, the next block is `101`).
- **Uniqueness by chain**: A block height refers to a position in _a specific blockchain_. Height `500,000` on one network is not comparable to the same height on another.

### Block height vs. block hash

- **Block height** is a simple index (e.g., `123456`).
- **Block hash** is a unique cryptographic identifier for a specific block.
- Because forks can create multiple competing blocks at the same height (temporarily), applications that need strict certainty often use:
  - the **block hash**, and/or
  - a **confirmation depth** (e.g., “6 blocks after height X”).

### Why block height matters

Block height is used throughout blockchain systems for:

- **Finality/confirmations**: “Wait until height is N blocks ahead” to reduce reorg risk.
- **State queries at a point in time**: Query balances, contract state, or logs “as of block height X.”
- **Protocol rules**: Network upgrades, parameter changes, and governance execution can be scheduled at specific heights.
- **Indexing and analytics**: Explorers, indexers, and data pipelines batch data by block ranges.

### Handling forks and reorgs

In most blockchains, there may be short-lived forks where:

- Two blocks exist at the same height on different branches.
- The network later converges on a canonical chain.
- A **reorg** replaces one branch’s blocks with another’s, meaning “the block at height X” can change briefly.

## On Sei Network

On Sei, block height plays the same core role—ordering blocks and enabling deterministic references to chain history—but is especially useful given Sei’s performance characteristics and EVM compatibility.

### Fast finality and high-throughput execution

- Sei is designed for high performance with **~400ms finality**, so block height advances quickly and is frequently used by apps for near-real-time UX.
- Sei’s parallelization and optimized execution mean many transactions can be processed efficiently per block; block height becomes a convenient “clock” for indexing and synchronization.

### EVM compatibility: using block height in smart contracts

In EVM contexts, block height corresponds to the EVM notion of the current block number (`block.number`). Solidity contracts can use block height for time/sequence-based logic (with the usual caveat: block height is not wall-clock time).

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

contract HeightGated {
    uint256 public immutable startHeight;

    constructor(uint256 _startHeight) {
        startHeight = _startHeight;
    }

    function isActive() public view returns (bool) {
        // On Sei EVM, block.number reflects the current block height.
        return block.number >= startHeight;
    }
}
```

### Querying block height from Sei nodes (RPC)

You can retrieve the latest block height via Tendermint/CometBFT RPC:

```bash
curl -s http://localhost:26657/status | jq -r .result.sync_info.latest_block_height
```

If you’re interacting via EVM-compatible JSON-RPC, you can read the current block number:

```bash
curl -s -X POST http://localhost:8545 \
  -H "Content-Type: application/json" \
  --data '{"jsonrpc":"2.0","method":"eth_blockNumber","params":[],"id":1}'
```

### Reading block height in application code

Example in TypeScript using an EVM provider:

```typescript
import { JsonRpcProvider } from 'ethers';

const provider = new JsonRpcProvider('http://localhost:8545');

async function main() {
  const blockNumber = await provider.getBlockNumber();
  console.log('Current block height:', blockNumber);
}

main().catch(console.error);
```

## Key Takeaways

- **Block height** is the sequential position of a block in a blockchain, used to reference and organize chain history.
- It supports confirmations, historical state queries, indexing, and protocol scheduling.
- On **Sei Network**, block height advances quickly due to **~400ms finality** and benefits high-throughput apps; it’s also directly accessible in **Sei’s EVM** as `block.number` and through standard RPC endpoints.

## Related Documentation

- [Getting Started](/learn)
- [Token Standards](/learn/dev-token-standards)
- [Staking](/learn/general-staking)
- [Oracles](/learn/oracles)

---

_Have a question that's not answered here? Join our [Discord](https://discord.gg/sei) community._
