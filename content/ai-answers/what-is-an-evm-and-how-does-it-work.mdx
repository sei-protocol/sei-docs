---
title: 'What is an EVM and How Does It Work?'
description: 'Learn about what is EVM and how it works in blockchain and on Sei Network.'
keywords: ['sei', 'blockchain', 'evm', 'what']
---

import { Callout } from 'nextra/components';

export const jsonLd = {
  '@context': 'https://schema.org',
  '@graph': [
    {
      '@type': 'FAQPage',
      mainEntity: [
        {
          '@type': 'Question',
          name: 'What is an EVM and How Does It Work?',
          acceptedAnswer: {
            '@type': 'Answer',
            text: 'The Ethereum Virtual Machine (EVM) is the execution environment that runs smart contract code and processes transactions on EVM-compatible blockchains. It defines a standardized set of rulesâ€”bytecode format, opcodes, gas accounting, and state transitionsâ€”so the same contract can execute deterministically across all nodes. In practice, the EVM is what makes Ethereum-style smart contracts portable across many networks.'
          }
        }
      ]
    },
    {
      '@type': 'TechArticle',
      headline: 'What is an EVM and How Does It Work?',
      description: 'Learn about what is EVM and how it works in blockchain and on Sei Network.',
      author: {
        '@type': 'Organization',
        name: 'Sei Network',
        url: 'https://sei.io'
      },
      publisher: {
        '@type': 'Organization',
        name: 'Sei Network',
        url: 'https://sei.io'
      },
      about: {
        '@type': 'Thing',
        name: 'what is EVM'
      },
      articleSection: 'evm',
      inLanguage: 'en'
    }
  ]
};

<head>
  <script type="application/ld+json" dangerouslySetInnerHTML={{ __html: JSON.stringify(jsonLd) }} />
</head>

# What is an EVM and How Does It Work?

<Callout type="info" emoji="ðŸ¤–">
  This content was generated with the assistance of AI and is intended for informational purposes only. Please verify all information independently before making decisions based on this content.
</Callout>

## Overview

The Ethereum Virtual Machine (EVM) is the execution environment that runs smart contract code and processes transactions on EVM-compatible blockchains. It defines a standardized set of rulesâ€”bytecode format, opcodes, gas accounting, and state transitionsâ€”so the same contract can execute deterministically across all nodes. In practice, the EVM is what makes Ethereum-style smart contracts portable across many networks.

## How It Works

### Deterministic execution and state

Blockchains must produce the same result on every node. The EVM enforces deterministic computation: given the same inputs (transaction data, current state), every node computes the same outputs (state updates, logs, return values). The EVM reads and writes to a global state that includes:

- **Account state**: balances, nonces, and contract code for contract accounts
- **Contract storage**: persistent keyâ€“value storage (32-byte slots)
- **Memory**: temporary, per-execution, byte-addressed memory
- **Stack**: a last-in-first-out stack used by EVM opcodes (up to 1024 items)

### Smart contracts: from Solidity to bytecode

Most contracts are written in a high-level language like Solidity, then compiled into **EVM bytecode**. Nodes execute this bytecode using the EVM instruction set (opcodes like `SSTORE`, `CALL`, `LOGn`, etc.).

**Example: a simple Solidity contract**

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

contract Counter {
    uint256 public number;

    function increment() external {
        number += 1;
    }
}
```

- `number` is stored in contract **storage**
- `increment()` translates into EVM opcodes that load the value, add 1, and persist it back to storage

### Transactions, message calls, and contract creation

EVM execution happens through:

- **External transactions** (signed by users/EOAs): can transfer value and/or call a contract
- **Internal calls** (message calls): contract-to-contract interactions using `CALL`, `DELEGATECALL`, etc.
- **Contract creation**: deploying a contract runs _creation bytecode_ and stores the resulting runtime bytecode on-chain

### Gas: metering computation and preventing abuse

The EVM uses **gas** to price computation and storage:

- Every opcode has a gas cost (e.g., storage writes are expensive)
- A transaction includes a **gas limit**
- If execution runs out of gas, state changes revert, but gas is still consumed
- This prevents infinite loops and allocates scarce block resources

### Logs and events

Contracts can emit **events** (logs) that are cheap to index and query off-chain. Logs are not part of contract storage, but theyâ€™re included in transaction receipts and are essential for building dApps (indexers, analytics, UIs).

### Reverts and error handling

EVM supports reverting execution with `REVERT` (and `require`/`revert` in Solidity). A revert rolls back state changes from the current call frame and returns error data.

## On Sei Network

Sei is a high-performance Layer 1 that supports **EVM compatibility**, allowing Solidity contracts and Ethereum tooling to run with minimal changes. That means developers can deploy familiar contracts and use standard libraries and workflows while benefiting from Seiâ€™s performance characteristics.

Key implications on Sei:

- **EVM compatibility**: You can use Solidity, EVM bytecode, and common tools (e.g., Foundry/Hardhat-style workflows) to build and deploy contracts to Seiâ€™s EVM environment.
- **High throughput via parallelization**: Sei is designed to parallelize transaction processing where possible, which can increase throughput for workloads with non-overlapping state access.
- **Fast finality (~400ms)**: Transactions reach finality quickly, improving UX for trading, gaming, and other latency-sensitive apps.

### Deploying and interacting (example workflow)

**Compile and deploy using Foundry (illustrative)**

```bash
# Compile
forge build

# Deploy (replace RPC URL and private key)
forge create \
  --rpc-url https://<sei-evm-rpc-endpoint> \
  --private-key $PRIVATE_KEY \
  src/Counter.sol:Counter
```

**Interact with the contract**

```bash
# Call a view function
cast call <CONTRACT_ADDRESS> "number()(uint256)" --rpc-url https://<sei-evm-rpc-endpoint>

# Send a transaction
cast send <CONTRACT_ADDRESS> "increment()" \
  --private-key $PRIVATE_KEY \
  --rpc-url https://<sei-evm-rpc-endpoint>
```

### What stays the same vs. what changes

- **Same**: Solidity contracts, ABI encoding, EVM opcodes, gas-based execution model, event/log semantics, and most Ethereum developer patterns.
- **Different**: Network-level performance characteristics (parallelization and fast finality) can change how quickly state updates are confirmed and how applications design around latency and throughput.

## Summary

The EVM is a deterministic, gas-metered virtual machine that executes smart contract bytecode and updates blockchain state in a verifiable way. It standardizes how contracts are deployed, called, and charged for computation. On Sei Network, EVM compatibility lets developers reuse Ethereum contracts and tooling while taking advantage of Seiâ€™s parallelized execution and ~400ms finality for high-performance applications.

## Related Documentation

- [EVM Overview](/evm)
- [Networks & RPC](/evm/networks)
- [Deploy with Hardhat](/evm/evm-hardhat)
- [Deploy with Foundry](/evm/evm-foundry)

---

_Have a question that's not answered here? Join our [Discord](https://discord.gg/sei) community._
