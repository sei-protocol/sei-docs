---
title: 'What is a Layer 2 Solution and How Does It Work?'
description: 'Learn about what is layer 2 solution and how it works in blockchain and on Sei Network.'
keywords: ['sei', 'blockchain', 'glossary', 'what', 'layer', 'solution']
---

import { Callout } from 'nextra/components';

export const jsonLd = {
  '@context': 'https://schema.org',
  '@graph': [
    {
      '@type': 'FAQPage',
      mainEntity: [
        {
          '@type': 'Question',
          name: 'What is a Layer 2 Solution and How Does It Work?',
          acceptedAnswer: {
            '@type': 'Answer',
            text: 'A Layer 2 (L2) solution is a blockchain scaling system built on top of a Layer 1 (L1) chain to increase throughput and reduce fees without changing the L1â€™s core consensus. It processes transactions off the L1 main chain (or in a separate execution environment) and then posts proofs or summarized data back to the L1 for security and settlement.'
          }
        }
      ]
    },
    {
      '@type': 'TechArticle',
      headline: 'What is a Layer 2 Solution and How Does It Work?',
      description: 'Learn about what is layer 2 solution and how it works in blockchain and on Sei Network.',
      author: {
        '@type': 'Organization',
        name: 'Sei Network',
        url: 'https://sei.io'
      },
      publisher: {
        '@type': 'Organization',
        name: 'Sei Network',
        url: 'https://sei.io'
      },
      about: {
        '@type': 'Thing',
        name: 'what is layer 2 solution'
      },
      articleSection: 'glossary',
      inLanguage: 'en'
    }
  ]
};

<head>
  <script type="application/ld+json" dangerouslySetInnerHTML={{ __html: JSON.stringify(jsonLd) }} />
</head>

# What is a Layer 2 Solution and How Does It Work?

<Callout type="info" emoji="ðŸ¤–">
  This content was generated with the assistance of AI and is intended for informational purposes only. Please verify all information independently before making decisions based on this content.
</Callout>

## Overview

A Layer 2 (L2) solution is a blockchain scaling system built on top of a Layer 1 (L1) chain to increase throughput and reduce fees without changing the L1â€™s core consensus. It processes transactions off the L1 main chain (or in a separate execution environment) and then posts proofs or summarized data back to the L1 for security and settlement.

## How It Works

Layer 2 systems generally follow the same pattern: **execute more transactions elsewhere**, then **use the L1 as the source of truth** for final settlement and security guarantees.

### Core Components

- **Execution environment**: Where transactions are processed (often off-chain or in a separate chain).
- **Data availability / posting**: Some or all transaction data is committed to the L1 so others can verify state changes.
- **Settlement and finality**: The L1 ultimately finalizes outcomes (balances, state transitions) based on L2 commitments.
- **Bridging**: Smart contracts on L1 and L2 lock/mint/burn assets to move value between layers.

### Common Layer 2 Designs

#### 1) Rollups (Optimistic and ZK)

Rollups batch many transactions and publish compressed results to the L1.

- **Optimistic Rollups**

  - Assume batches are valid by default.
  - Allow challenges during a dispute window (fraud proofs).
  - Typically have longer withdrawal times due to challenge periods.

- **ZK Rollups**
  - Publish a validity proof (e.g., SNARK/STARK) showing the batch is correct.
  - Faster finality for withdrawals (depending on design), often higher proving complexity.

#### 2) State Channels

Participants lock funds in an L1 contract and transact off-chain by exchanging signed messages. Only opening/closing (and disputes) touch the L1.

#### 3) Sidechains (often grouped with L2, but security differs)

A sidechain is a separate blockchain with its own consensus. It can bridge to an L1, but typically does **not** inherit L1 security in the same way rollups do.

### Typical L2 Flow (High-Level)

1. **Deposit / Bridge to L2**: User locks assets on L1; L2 credits the user.
2. **Transact on L2**: Many transactions occur quickly and cheaply.
3. **Batch & Commit**: L2 batches transactions and posts commitments (and sometimes data/proofs) to L1.
4. **Settle / Withdraw**: User withdraws back to L1 under the L2â€™s security model (immediate with validity proofs, delayed with optimistic dispute windows, etc.).

## On Sei Network

Sei is a high-performance **Layer 1** with **EVM compatibility**, designed to scale on-chain execution directlyâ€”reducing the need to rely on external Layer 2s for performance. Key traits that affect how you think about L2s when building on Sei:

- **Parallelization**: Sei is built for high throughput by executing compatible workloads in parallel, improving performance for many applications compared to single-threaded execution environments.
- **~400ms finality**: Fast finality reduces latency for trading, games, and real-time apps, which are often pushed to L2s on slower L1s.
- **EVM compatibility**: Solidity smart contracts and EVM tooling can be used on Sei, enabling Ethereum-style development while benefiting from Seiâ€™s L1 performance characteristics.

### What This Means Practically

- Many teams that would normally choose an L2 for faster execution and cheaper transactions can often deploy directly on Sei L1 while still achieving strong performance characteristics.
- If you do use an L2 or an appchain-style architecture, Sei can serve as a fast finality settlement layer or as the primary execution layer with bridges to other ecosystems via standard bridging patterns.

### Example: Basic Bridging Pattern (Conceptual)

Below is a simplified example of how an L1 bridge contract might lock funds and emit an event that an L2 relayer/sequencer uses to mint or credit funds on the L2.

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

contract SimpleBridgeL1 {
    event Deposited(address indexed user, uint256 amount, bytes32 indexed l2Recipient);

    receive() external payable {
        deposit(bytes32(uint256(uint160(msg.sender))));
    }

    function deposit(bytes32 l2Recipient) public payable {
        require(msg.value > 0, "No value");
        emit Deposited(msg.sender, msg.value, l2Recipient);
        // In real bridges, additional accounting, proofs, and security checks apply.
    }
}
```

On Sei, the same Solidity/EVM pattern applies for EVM-based contracts. With Seiâ€™s fast finality and parallelized execution, you may be able to keep more logic on L1 while still delivering user experiences that typically motivate L2 adoption elsewhere.

## Key Benefits and Tradeoffs

### Benefits

- **Lower fees**: Batching and off-chain execution reduce per-transaction costs.
- **Higher throughput**: More transactions per second by moving execution off L1.
- **Better UX**: Faster confirmations (depending on design).

### Tradeoffs

- **Bridge risk**: Bridges are complex and often targeted.
- **Security model differences**: Sidechains and some L2 designs donâ€™t inherit full L1 security.
- **Withdrawal delays**: Optimistic systems may require waiting for challenge periods.
- **Operational complexity**: Sequencers, provers, and relayers add infrastructure requirements.

## Summary

Layer 2 solutions scale blockchains by moving transaction execution away from the base chain and using the Layer 1 for settlement, security, and dispute resolution. On Sei Network, high-performance L1 featuresâ€”parallelization, ~400ms finality, and EVM compatibilityâ€”often allow developers to achieve L2-like performance directly on L1, while still remaining compatible with Ethereum-style tooling and smart contracts.

## Related Documentation

- [Getting Started](/learn)
- [Token Standards](/learn/dev-token-standards)
- [Staking](/learn/general-staking)
- [Oracles](/learn/oracles)

---

_Have a question that's not answered here? Join our [Discord](https://discord.gg/sei) community._
