---
title: 'What is a Genesis Block and How Does It Work?'
description: 'Learn about what is genesis block and how it works in blockchain and on Sei Network.'
keywords: ['sei', 'blockchain', 'glossary', 'what', 'genesis', 'block']
---

import { Callout } from 'nextra/components';

export const jsonLd = {
  '@context': 'https://schema.org',
  '@graph': [
    {
      '@type': 'FAQPage',
      mainEntity: [
        {
          '@type': 'Question',
          name: 'What is a Genesis Block and How Does It Work?',
          acceptedAnswer: {
            '@type': 'Answer',
            text: 'A genesis block is the very first block in a blockchain, serving as the starting point from which all subsequent blocks are linked and validated. It is hardcoded (or deterministically defined) in a network‚Äôs software and establishes the initial state‚Äîsuch as initial token balances, chain parameters, and consensus settings.'
          }
        }
      ]
    },
    {
      '@type': 'TechArticle',
      headline: 'What is a Genesis Block and How Does It Work?',
      description: 'Learn about what is genesis block and how it works in blockchain and on Sei Network.',
      author: {
        '@type': 'Organization',
        name: 'Sei Network',
        url: 'https://sei.io'
      },
      publisher: {
        '@type': 'Organization',
        name: 'Sei Network',
        url: 'https://sei.io'
      },
      about: {
        '@type': 'Thing',
        name: 'what is genesis block'
      },
      articleSection: 'glossary',
      inLanguage: 'en'
    }
  ]
};

<head>
  <script type="application/ld+json" dangerouslySetInnerHTML={{ __html: JSON.stringify(jsonLd) }} />
</head>

# What is a Genesis Block and How Does It Work?

<Callout type="info" emoji="ü§ñ">
  This content was generated with the assistance of AI and is intended for informational purposes only. Please verify all information independently before making decisions based on this content.
</Callout>

## Overview

A genesis block is the very first block in a blockchain, serving as the starting point from which all subsequent blocks are linked and validated. It is hardcoded (or deterministically defined) in a network‚Äôs software and establishes the initial state‚Äîsuch as initial token balances, chain parameters, and consensus settings.

Because there is no prior block to reference, the genesis block is unique: it anchors the chain‚Äôs history and provides the root of trust for verifying every block that follows.

## How It Works

### 1) Establishes the initial chain state

In most blockchains, the genesis block defines the initial ledger state, often including:

- Initial supply and account balances (genesis allocations)
- Validator set or staking configuration (for Proof-of-Stake chains)
- Network parameters (block time targets, gas limits, governance settings, etc.)
- Initial module/contract state (where applicable)

This state is typically represented as a **genesis file** (e.g., JSON) that a node loads on first startup.

### 2) Has no ‚Äúprevious hash‚Äù

Normal blocks include a `previousBlockHash` field pointing to the prior block. The genesis block does not have a real predecessor, so its ‚Äúprevious hash‚Äù is usually set to a constant (often all zeros) or handled specially by the protocol.

### 3) Creates the chain‚Äôs canonical starting hash

Once nodes agree on the genesis configuration, they can compute the genesis block hash (or an equivalent chain identifier) and use it to:

- Ensure they are joining the correct network
- Reject peers on a different chain (even if the software is similar)
- Validate that subsequent blocks correctly link back to the genesis

### 4) Network identity and safety

A chain typically also has a **chain ID** associated with the genesis configuration. This helps prevent replay attacks across networks (e.g., preventing a transaction signed for testnet from being valid on mainnet).

### 5) Practical node behavior

When a node starts:

1. It loads the genesis state.
2. It initializes its local database with the genesis block/state.
3. It begins syncing blocks from peers, verifying each block‚Äôs linkage and validity back to genesis.

## On Sei Network

Sei Network uses a genesis configuration to bootstrap the chain‚Äôs initial state and consensus parameters, and all nodes must share the same genesis to join the same Sei network (e.g., mainnet vs testnet). Once initialized, Sei‚Äôs architecture emphasizes high throughput via parallelization, and the chain reaches rapid confirmation with ~400ms finality, but the trust anchor remains the same: every finalized block is ultimately verifiable back to the genesis state.

Because Sei is EVM-compatible, the genesis state can also include EVM-related configuration (such as chain ID used by EVM wallets and tooling) so that Ethereum-style transactions and smart contracts operate consistently on Sei.

## Example: What a Genesis File Looks Like (Conceptually)

Genesis formats vary by chain, but a simplified, conceptual example often includes a chain ID, initial accounts, and consensus configuration:

```json
{
  "chain_id": "sei-mainnet-1",
  "genesis_time": "2024-01-01T00:00:00Z",
  "app_state": {
    "bank": {
      "balances": [{ "address": "sei1...", "coins": [{ "denom": "usei", "amount": "1000000" }] }]
    },
    "staking": {
      "params": { "bond_denom": "usei" }
    }
  }
}
```

## Example: Verifying You‚Äôre on the Right Chain

When running infrastructure, you typically confirm that your node is using the correct chain ID and genesis:

```bash
seid status | jq '.NodeInfo.network, .NodeInfo.protocol_version'
```

(Exact fields and tooling can vary by environment, but the principle is consistent: confirm the node‚Äôs network identity and that it bootstrapped from the expected genesis.)

## Key Takeaways

- The genesis block is the first block and the foundation of a blockchain‚Äôs history.
- It defines the initial state and parameters that all nodes must agree on.
- All future block validation ultimately traces back to the genesis.
- On Sei Network, genesis anchors the chain while Sei‚Äôs parallelization and ~400ms finality drive fast, scalable execution on top of that foundation, including EVM-compatible workflows.

## Related Documentation

- [Getting Started](/learn)
- [Token Standards](/learn/dev-token-standards)
- [Staking](/learn/general-staking)
- [Oracles](/learn/oracles)

---

_Have a question that's not answered here? Join our [Discord](https://discord.gg/sei) community._
