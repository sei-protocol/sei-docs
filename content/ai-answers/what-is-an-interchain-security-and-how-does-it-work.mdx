---
title: 'What is an Interchain Security and How Does It Work?'
description: 'Learn about what is interchain security and how it works in blockchain and on Sei Network.'
keywords: ['sei', 'blockchain', 'glossary', 'what', 'interchain', 'security']
---

import { Callout } from 'nextra/components';

export const jsonLd = {
  '@context': 'https://schema.org',
  '@graph': [
    {
      '@type': 'FAQPage',
      mainEntity: [
        {
          '@type': 'Question',
          name: 'What is an Interchain Security and How Does It Work?',
          acceptedAnswer: {
            '@type': 'Answer',
            text: 'Interchain Security is a model where one blockchain (a provider chain) extends its economic security‚Äîtypically backed by staked assets and validator participation‚Äîto other blockchains (the consumer chains). Instead of each new chain bootstrapping its own validator set and stake, it can ‚Äúrent‚Äù or inherit security from an established chain to reduce startup risk and accelerate decentralization.'
          }
        }
      ]
    },
    {
      '@type': 'TechArticle',
      headline: 'What is an Interchain Security and How Does It Work?',
      description: 'Learn about what is interchain security and how it works in blockchain and on Sei Network.',
      author: {
        '@type': 'Organization',
        name: 'Sei Network',
        url: 'https://sei.io'
      },
      publisher: {
        '@type': 'Organization',
        name: 'Sei Network',
        url: 'https://sei.io'
      },
      about: {
        '@type': 'Thing',
        name: 'what is interchain security'
      },
      articleSection: 'glossary',
      inLanguage: 'en'
    }
  ]
};

<head>
  <script type="application/ld+json" dangerouslySetInnerHTML={{ __html: JSON.stringify(jsonLd) }} />
</head>

# What is an Interchain Security and How Does It Work?

<Callout type="info" emoji="ü§ñ">
  This content was generated with the assistance of AI and is intended for informational purposes only. Please verify all information independently before making decisions based on this content.
</Callout>

## Overview

Interchain Security is a model where one blockchain (a **provider** chain) extends its economic security‚Äîtypically backed by staked assets and validator participation‚Äîto other blockchains (the **consumer** chains). Instead of each new chain bootstrapping its own validator set and stake, it can ‚Äúrent‚Äù or inherit security from an established chain to reduce startup risk and accelerate decentralization.

At a high level, it enables multiple sovereign chains to share a common security base while still running their own application logic and state.

## How It Works

### Core Idea: Shared Validator Set and Slashing

In most Proof-of-Stake (PoS) systems, security comes from:

- **Validators** staking tokens
- **Consensus** among validators to produce/validate blocks
- **Slashing** penalties for misbehavior (e.g., double-signing) and downtime

Interchain Security generalizes this by allowing validators from a provider chain to also validate one or more consumer chains. The provider chain‚Äôs stake and slashing conditions can be used to economically secure the consumer chain.

### Typical Flow

1. **Provider chain establishes security rules**  
   The provider chain defines how validator assignments, signing requirements, and slashing events from consumer chains are handled.

2. **Consumer chain connects via interchain messaging**  
   Consumer chains communicate validator set updates, block commitments, and evidence of misbehavior back to the provider chain (often via IBC in Cosmos-style ecosystems).

3. **Validators run additional processes**  
   Validators on the provider chain also run nodes for consumer chains (or otherwise participate in their consensus), producing and validating blocks for them.

4. **Rewards and fees are shared**  
   Consumer chain transaction fees and/or inflation rewards may be routed back to provider chain validators/delegators, creating incentives to secure the consumer chain.

5. **Misbehavior is enforced economically**  
   If a validator misbehaves on a consumer chain, the evidence can be relayed to the provider chain, which applies **slashing** to the validator‚Äôs stake on the provider chain‚Äîmaking attacks costly.

### Security and Trade-offs

**Benefits**

- Faster launch for new chains without needing to bootstrap stake/validators
- Higher security posture early on (assuming provider chain is robust)
- Better alignment of incentives across an ecosystem

**Trade-offs**

- Operational overhead for validators (more chains to run)
- Shared fate: issues on consumer chains can create load or risk for provider validators
- Governance and coordination complexity (upgrades, parameter changes, dispute handling)

## On Sei Network

Sei is a high-performance Layer 1 with **EVM compatibility**, **parallelized execution**, and **~400ms finality**. While Interchain Security is most commonly discussed as a PoS security-sharing pattern (often implemented in Cosmos ecosystems), the practical equivalent considerations on Sei typically show up as:

- **Application deployment without bootstrapping a new chain:** Teams can deploy applications directly on Sei‚Äôs base layer (including EVM smart contracts), leveraging Sei‚Äôs existing validator set and economic security instead of launching a separate consumer chain.
- **High-throughput security for multi-app environments:** Sei‚Äôs **parallelization** helps scale many applications concurrently, and fast finality reduces the window for reorg risk‚Äîboth important for apps that might otherwise consider a dedicated chain for performance reasons.
- **EVM compatibility for shared security:** EVM dApps can inherit Sei‚Äôs base-layer security model while using familiar tooling (Solidity, Hardhat/Foundry, ethers/web3 libraries).

### When you might choose Sei instead of a consumer chain

Interchain Security is often attractive when you want chain sovereignty but don‚Äôt want to bootstrap security. If your goal is primarily performance, fast settlement, and security without running your own consensus/validator infrastructure, deploying on Sei can be a simpler path‚Äîwhile still benefiting from rapid finality and parallel execution.

## Example: Deploying an EVM Contract on Sei (Shared L1 Security)

Below is a minimal Solidity contract and a deployment flow that illustrates the ‚Äúshared security‚Äù experience: your app runs under Sei‚Äôs validator set and consensus, rather than needing its own.

### Solidity contract

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

contract Counter {
    uint256 public value;

    function inc() external {
        value += 1;
    }
}
```

### Deploy with Foundry (example)

```bash
# 1) Initialize a Foundry project
forge init sei-counter
cd sei-counter

# 2) Add the contract (e.g., src/Counter.sol), then build
forge build

# 3) Deploy (replace RPC_URL and PRIVATE_KEY with your Sei EVM endpoint and key)
export RPC_URL="https://<sei-evm-rpc-endpoint>"
export PRIVATE_KEY="0x..."

forge create --rpc-url "$RPC_URL" --private-key "$PRIVATE_KEY" src/Counter.sol:Counter
```

In this model, the contract‚Äôs state transitions and finality are secured by Sei‚Äôs L1 consensus (with fast finality and parallel execution characteristics), rather than by a separate consumer chain‚Äôs validator set.

## Related Terms

- **Provider chain / Consumer chain:** Chains that supply security vs. chains that consume it
- **Shared security:** The broader concept of reusing an established security base across multiple domains
- **Slashing:** Economic penalties applied to staked validators for misbehavior
- **Finality:** The point at which a transaction is considered irreversible (Sei targets ~400ms)

## Related Documentation

- [Getting Started](/learn)
- [Token Standards](/learn/dev-token-standards)
- [Staking](/learn/general-staking)
- [Oracles](/learn/oracles)

---

_Have a question that's not answered here? Join our [Discord](https://discord.gg/sei) community._
