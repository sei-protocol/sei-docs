---
title: 'What is a Zero-knowledge Proof and How Does It Work?'
description: 'Learn about what is zero-knowledge proof and how it works in blockchain and on Sei Network.'
keywords: ['sei', 'blockchain', 'glossary', 'what', 'zero-knowledge', 'proof', 'zero', 'knowledge']
---

import { Callout } from 'nextra/components';

export const jsonLd = {
  '@context': 'https://schema.org',
  '@graph': [
    {
      '@type': 'FAQPage',
      mainEntity: [
        {
          '@type': 'Question',
          name: 'What is a Zero-knowledge Proof and How Does It Work?',
          acceptedAnswer: {
            '@type': 'Answer',
            text: 'A zero-knowledge proof (ZKP) is a cryptographic method that lets a prover convince a verifier that a statement is true without revealing the underlying data (the ‚Äúwitness‚Äù) that makes it true. In other words, you can prove knowledge or correctness while keeping inputs private. ZKPs are widely used for privacy, identity, and scaling in blockchain systems.'
          }
        }
      ]
    },
    {
      '@type': 'TechArticle',
      headline: 'What is a Zero-knowledge Proof and How Does It Work?',
      description: 'Learn about what is zero-knowledge proof and how it works in blockchain and on Sei Network.',
      author: {
        '@type': 'Organization',
        name: 'Sei Network',
        url: 'https://sei.io'
      },
      publisher: {
        '@type': 'Organization',
        name: 'Sei Network',
        url: 'https://sei.io'
      },
      about: {
        '@type': 'Thing',
        name: 'what is zero-knowledge proof'
      },
      articleSection: 'glossary',
      inLanguage: 'en'
    }
  ]
};

<head>
  <script type="application/ld+json" dangerouslySetInnerHTML={{ __html: JSON.stringify(jsonLd) }} />
</head>

# What is a Zero-knowledge Proof and How Does It Work?

<Callout type="info" emoji="ü§ñ">
  This content was generated with the assistance of AI and is intended for informational purposes only. Please verify all information independently before making decisions based on this content.
</Callout>

## Overview

A zero-knowledge proof (ZKP) is a cryptographic method that lets a **prover** convince a **verifier** that a statement is true **without revealing** the underlying data (the ‚Äúwitness‚Äù) that makes it true. In other words, you can prove knowledge or correctness while keeping inputs private. ZKPs are widely used for privacy, identity, and scaling in blockchain systems.

## How It Works

In a typical zero-knowledge protocol, there are two roles:

- **Prover**: Holds secret information (the witness) and generates a proof.
- **Verifier**: Checks the proof and becomes convinced the statement is true.

For a proof system to be considered ‚Äúzero-knowledge,‚Äù it generally aims to satisfy:

- **Completeness**: If the statement is true and both parties follow the protocol, the verifier will accept.
- **Soundness**: If the statement is false, a dishonest prover should not be able to convince the verifier (except with negligible probability).
- **Zero-knowledge**: The verifier learns nothing about the witness beyond the fact that the statement is true.

### Intuition with an Example

Suppose you want to prove: ‚ÄúI know the password that unlocks this hash‚Äù without revealing the password.

- The **statement** might be: `hash(password) == H`
- The **witness** is the actual `password`
- The prover generates a proof that they know a preimage of `H` under the hash function, without exposing the preimage.

### Common ZKP Families (High-Level)

- **zk-SNARKs**: Succinct proofs with fast verification and small proof sizes; typically require a setup (depending on the SNARK).
- **zk-STARKs**: Transparent (no trusted setup), often larger proofs, strong security assumptions.
- **Bulletproofs**: No trusted setup, commonly used for range proofs; verification cost can be higher.

### Where ZKPs Are Used in Blockchains

- **Privacy**: Hide transaction amounts, senders/recipients, or sensitive state while preserving validity.
- **Scalability**: Prove large batches of computation off-chain and verify them on-chain (e.g., rollups).
- **Identity & compliance**: Prove ‚ÄúI‚Äôm over 18‚Äù or ‚ÄúI‚Äôm not on a sanctions list‚Äù without revealing full identity details.
- **Verifiable computation**: Prove a program ran correctly with private inputs.

## On Sei Network

Sei is a high-performance Layer 1 with **EVM compatibility**, designed for fast execution and user experience. While zero-knowledge proofs are not inherently ‚Äúbuilt in‚Äù as a mandatory mechanism for every transaction, they are highly relevant to Sei developers and applications for several reasons:

- **EVM compatibility**: ZK-enabled applications and tooling from the broader Ethereum ecosystem (e.g., proof verifiers, zk identity primitives, zk rollup bridges) can be adapted to Sei‚Äôs EVM environment.
- **High throughput and parallelization**: Sei‚Äôs parallelized execution model can help applications that verify proofs on-chain (which can be computationally heavy) by improving overall chain performance and reducing contention across transactions that touch different state.
- **Fast finality (~400ms)**: For zk-powered apps (private transfers, zk attestations, proof-gated access, etc.), fast finality improves UX: proofs can be verified and state changes can be confirmed quickly.

### Verifying a ZK Proof from an EVM Smart Contract (Conceptual)

Many ZK systems provide a verifier contract that exposes a function like `verifyProof(...)`. A typical Solidity pattern looks like this (interface varies by ZK system):

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

interface IVerifier {
    function verifyProof(
        uint256[2] calldata a,
        uint256[2][2] calldata b,
        uint256[2] calldata c,
        uint256[] calldata publicInputs
    ) external view returns (bool);
}

contract ZKGatedAccess {
    IVerifier public verifier;

    constructor(address verifierAddress) {
        verifier = IVerifier(verifierAddress);
    }

    function enter(
        uint256[2] calldata a,
        uint256[2][2] calldata b,
        uint256[2] calldata c,
        uint256[] calldata publicInputs
    ) external view returns (bool) {
        // Example: publicInputs could encode ‚Äúuser is in allowlist‚Äù or ‚Äúmeets criteria‚Äù
        return verifier.verifyProof(a, b, c, publicInputs);
    }
}
```

On Sei‚Äôs EVM, this model works similarly to other EVM chains: the proof is generated off-chain, then submitted to the contract for verification. Applications often combine this with Sei‚Äôs fast finality for responsive user flows.

### Typical ZK Application Flows on Sei

- **ZK identity/attestations**: Users generate proofs that they meet a requirement (membership, uniqueness, age threshold) and submit only the proof on-chain.
- **Private game/market logic**: Prove correctness of actions without revealing strategy or hidden information.
- **Bridging and interoperability**: ZK proofs can be used in bridge designs to attest to state transitions or events across systems.

## Minimal Off-Chain Flow (Example)

Below is a high-level TypeScript-style flow (exact APIs depend on the proving system):

```typescript
// 1) Prepare private witness and public inputs
const witness = { secret: '...' };
const publicInputs = [
  /* e.g., merkleRoot, nullifierHash */
];

// 2) Generate proof off-chain (library-specific)
const { proof, calldata } = await prover.generateProof(witness, publicInputs);

// 3) Submit proof to Sei EVM contract
const tx = await zkGatedAccess.enter(calldata.a, calldata.b, calldata.c, calldata.publicInputs);
await tx.wait(); // Sei finality is fast (~400ms), improving UX
```

## Key Takeaways

- A zero-knowledge proof lets you prove a statement is true without revealing the secret data behind it.
- ZKPs support privacy, scalability, identity, and verifiable computation in blockchain systems.
- On Sei Network, ZK applications can benefit from **EVM compatibility**, **parallelized execution**, and **fast finality (~400ms)** to build responsive, proof-driven user experiences.

## Related Documentation

- [Getting Started](/learn)
- [Token Standards](/learn/dev-token-standards)
- [Staking](/learn/general-staking)
- [Oracles](/learn/oracles)

---

_Have a question that's not answered here? Join our [Discord](https://discord.gg/sei) community._
