---
title: 'What is a Sidechain and How Does It Work?'
description: 'Learn about what is sidechain and how it works in blockchain and on Sei Network.'
keywords: ['sei', 'blockchain', 'glossary', 'what', 'sidechain']
---

import { Callout } from 'nextra/components';

export const jsonLd = {
  '@context': 'https://schema.org',
  '@graph': [
    {
      '@type': 'FAQPage',
      mainEntity: [
        {
          '@type': 'Question',
          name: 'What is a Sidechain and How Does It Work?',
          acceptedAnswer: {
            '@type': 'Answer',
            text: 'A sidechain is an independent blockchain that runs in parallel to a ‚Äúmain‚Äù blockchain (often called the mainchain or Layer 1) and is connected to it through a bridge. Sidechains typically have their own consensus rules, validator set, and block production, enabling different performance, fee, and feature tradeoffs than the mainchain.'
          }
        }
      ]
    },
    {
      '@type': 'TechArticle',
      headline: 'What is a Sidechain and How Does It Work?',
      description: 'Learn about what is sidechain and how it works in blockchain and on Sei Network.',
      author: {
        '@type': 'Organization',
        name: 'Sei Network',
        url: 'https://sei.io'
      },
      publisher: {
        '@type': 'Organization',
        name: 'Sei Network',
        url: 'https://sei.io'
      },
      about: {
        '@type': 'Thing',
        name: 'what is sidechain'
      },
      articleSection: 'glossary',
      inLanguage: 'en'
    }
  ]
};

<head>
  <script type="application/ld+json" dangerouslySetInnerHTML={{ __html: JSON.stringify(jsonLd) }} />
</head>

# What is a Sidechain and How Does It Work?

<Callout type="info" emoji="ü§ñ">
  This content was generated with the assistance of AI and is intended for informational purposes only. Please verify all information independently before making decisions based on this content.
</Callout>

## Overview

A **sidechain** is an independent blockchain that runs in parallel to a ‚Äúmain‚Äù blockchain (often called the **mainchain** or **Layer 1**) and is connected to it through a bridge. Sidechains typically have their own consensus rules, validator set, and block production, enabling different performance, fee, and feature tradeoffs than the mainchain.

## How It Works

Sidechains generally work by moving assets and data between chains via a **bridge**:

- **Two-way asset transfer (peg):**

  - Users **lock** assets on the mainchain (e.g., in a bridge contract or custody mechanism).
  - A corresponding representation is **minted** or **released** on the sidechain (e.g., a wrapped token).
  - To return, users **burn** or lock the sidechain representation, then **unlock** the original asset on the mainchain.

- **Bridge validation & security model:**

  - Many sidechains rely on a separate validator set, a multisig, or a light-client/relayer system to confirm events between chains.
  - This means a sidechain often has **independent security** from the mainchain‚Äîif the sidechain or its bridge is compromised, bridged assets can be at risk even if the mainchain remains secure.

- **Why sidechains exist:**
  - **Scalability:** Offload activity from a congested mainchain.
  - **Customization:** Implement different VM features, gas rules, privacy, or governance.
  - **Lower fees / faster blocks:** Different consensus parameters can reduce cost and latency.

### Minimal flow example (conceptual)

1. User deposits Token A into a mainchain bridge contract.
2. Bridge emits an on-chain event: `Deposit(user, amount, destination)`.
3. Bridge operators/relayers observe the event and submit proof/confirmation to the sidechain.
4. Sidechain mints `WrappedA` to the user.
5. For withdrawal, the process is reversed.

## On Sei Network

Sei Network is a high-performance Layer 1 with **EVM compatibility**, designed for fast, efficient execution and a strong developer experience. In many cases, apps that might use a sidechain elsewhere can deploy directly on Sei to benefit from:

- **Parallelized execution** (Sei‚Äôs architecture is built to process compatible transactions concurrently)
- **~400ms finality** for rapid confirmations
- **EVM compatibility** so Solidity contracts and Ethereum tooling can be reused

That said, sidechains can still be relevant in a Sei-centric ecosystem:

- **Sei as the ‚Äúmainchain‚Äù:** A project could run a custom sidechain for specialized requirements (custom consensus, app-specific rules, bespoke data availability), and bridge assets to/from Sei for liquidity and interoperability.
- **Sei as a high-performance settlement/execution layer:** Teams may choose to consolidate activity on Sei instead of maintaining a separate sidechain, reducing operational overhead and avoiding the independent-security tradeoffs of sidechains.
- **EVM bridging patterns:** Because Sei supports EVM, many familiar bridging patterns (lock/mint, burn/unlock, event-driven relayers) apply, with the added benefit of fast finality for bridge state changes.

## Common Sidechain Bridge Pattern (EVM Example)

Below is a simplified Solidity sketch of a **lock-and-emit** contract on a mainchain (or one side of a bridge). A relayer typically watches the `Deposited` event and triggers minting on the destination chain.

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

interface IERC20 {
  function transferFrom(address from, address to, uint256 amount) external returns (bool);
}

contract SimpleBridgeLockbox {
  event Deposited(address indexed token, address indexed from, bytes32 indexed destination, uint256 amount);

  function deposit(address token, uint256 amount, bytes32 destination) external {
    require(amount > 0, "amount=0");
    require(IERC20(token).transferFrom(msg.sender, address(this), amount), "transfer failed");
    emit Deposited(token, msg.sender, destination, amount);
  }
}
```

And a minimal TypeScript listener pattern (relayer-side) that reacts to deposits:

```typescript
import { ethers } from 'ethers';

const provider = new ethers.JsonRpcProvider(process.env.RPC_URL);
const bridgeAbi = ['event Deposited(address indexed token, address indexed from, bytes32 indexed destination, uint256 amount)'];

async function main() {
  const bridge = new ethers.Contract(process.env.BRIDGE_ADDRESS!, bridgeAbi, provider);

  bridge.on('Deposited', async (token, from, destination, amount, event) => {
    // In production: verify confirmations/finality, prevent replay, and submit proof/tx to the destination chain.
    console.log('Deposit observed:', { token, from, destination, amount: amount.toString(), tx: event.log.transactionHash });
  });
}

main().catch(console.error);
```

## Key Tradeoffs and Considerations

- **Security:** Sidechains usually do not inherit the full security of the mainchain; the bridge and sidechain validators become critical trust assumptions.
- **Finality & UX:** Faster finality improves bridging UX. Sei‚Äôs ~400ms finality can reduce perceived latency for bridge-related state transitions.
- **Liquidity fragmentation:** Assets split across chains can reduce liquidity depth unless bridges are robust and widely used.
- **Operational complexity:** Running and maintaining a sidechain + bridge is significantly more complex than deploying directly on a high-performance L1.

## Summary

A sidechain is a separate blockchain connected to a mainchain via a bridge, enabling different performance and feature profiles while introducing additional security and operational considerations. In Sei‚Äôs ecosystem, many teams can achieve high throughput and low latency directly on Sei thanks to parallelization, ~400ms finality, and EVM compatibility‚Äîwhile sidechains remain an option for specialized needs that require custom chain-level control.

## Related Documentation

- [Getting Started](/learn)
- [Token Standards](/learn/dev-token-standards)
- [Staking](/learn/general-staking)
- [Oracles](/learn/oracles)

---

_Have a question that's not answered here? Join our [Discord](https://discord.gg/sei) community._
