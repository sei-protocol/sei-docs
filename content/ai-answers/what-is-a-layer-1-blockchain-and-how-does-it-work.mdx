---
title: 'What is a Layer 1 Blockchain and How Does It Work?'
description: 'Learn about what is layer 1 blockchain and how it works in blockchain and on Sei Network.'
keywords: ['sei', 'blockchain', 'glossary', 'what', 'layer', 'blockchain']
---

import { Callout } from 'nextra/components';

export const jsonLd = {
  '@context': 'https://schema.org',
  '@graph': [
    {
      '@type': 'FAQPage',
      mainEntity: [
        {
          '@type': 'Question',
          name: 'What is a Layer 1 Blockchain and How Does It Work?',
          acceptedAnswer: {
            '@type': 'Answer',
            text: 'A Layer 1 (L1) blockchain is the base network where transactions are executed, blocks are produced, and consensus is achieved‚Äîwithout relying on another chain for security or settlement. It provides the core rules, validator set, and data availability that applications and Layer 2 solutions build on.'
          }
        }
      ]
    },
    {
      '@type': 'TechArticle',
      headline: 'What is a Layer 1 Blockchain and How Does It Work?',
      description: 'Learn about what is layer 1 blockchain and how it works in blockchain and on Sei Network.',
      author: {
        '@type': 'Organization',
        name: 'Sei Network',
        url: 'https://sei.io'
      },
      publisher: {
        '@type': 'Organization',
        name: 'Sei Network',
        url: 'https://sei.io'
      },
      about: {
        '@type': 'Thing',
        name: 'what is layer 1 blockchain'
      },
      articleSection: 'glossary',
      inLanguage: 'en'
    }
  ]
};

<head>
  <script type="application/ld+json" dangerouslySetInnerHTML={{ __html: JSON.stringify(jsonLd) }} />
</head>

# What is a Layer 1 Blockchain and How Does It Work?

<Callout type="info" emoji="ü§ñ">
  This content was generated with the assistance of AI and is intended for informational purposes only. Please verify all information independently before making decisions based on this content.
</Callout>

## Overview

A Layer 1 (L1) blockchain is the base network where transactions are executed, blocks are produced, and consensus is achieved‚Äîwithout relying on another chain for security or settlement. It provides the core rules, validator set, and data availability that applications and Layer 2 solutions build on.

## How It Works

### 1) Core components of a Layer 1

Layer 1 blockchains typically include:

- **Consensus mechanism**: The method validators use to agree on the next block (e.g., Proof of Stake). Consensus determines finality, security assumptions, and performance.
- **Validators / nodes**: Participants that propose, verify, and finalize blocks. Validators stake value (in PoS systems) and can be penalized for misbehavior.
- **Execution layer (state machine)**: The logic that applies transactions to update chain state (account balances, smart contract storage, etc.).
- **Networking (P2P gossip)**: Propagates transactions and blocks across nodes.
- **Mempool**: A waiting area where pending transactions sit before inclusion in a block.
- **Data availability**: Ensures transaction data is published on-chain so anyone can verify the state transitions.

### 2) Transaction lifecycle on an L1

In general, a transaction on a Layer 1 follows this flow:

1. **User signs a transaction** with a private key and broadcasts it to the network.
2. **Nodes receive and validate** the transaction (signature, nonce, fee, basic rules).
3. **Transaction enters the mempool** and competes for block inclusion (often fee-based ordering).
4. **A validator proposes a block** containing a set of transactions.
5. **Other validators verify** the block and reach consensus.
6. **Finality** is achieved (either probabilistic or deterministic), meaning the transaction is considered confirmed and increasingly hard (or impossible) to revert.
7. **State is updated** across all nodes (balances, contract storage, logs/events, etc.).

### 3) Smart contracts and programmability

Many Layer 1s support smart contracts, allowing applications to run directly on the base chain. In EVM-based environments, contracts are written in Solidity and executed by the Ethereum Virtual Machine, producing deterministic state changes that all validators can verify.

### 4) Scaling approaches at Layer 1

Layer 1s scale by improving throughput and latency through techniques such as:

- **Parallel execution** of non-conflicting transactions
- **Efficient block propagation and consensus**
- **Optimized fee markets and mempool design**
- **State and storage optimizations**

Layer 2 networks (rollups, channels) can further scale by executing off-chain and settling on the L1, but the L1 remains the root of security and settlement.

## On Sei Network

Sei is a high-performance Layer 1 designed for low-latency, high-throughput on-chain execution. It combines **fast finality (around ~400ms)** with **parallelization**, and it supports **EVM compatibility**, enabling Solidity-based smart contracts and Ethereum tooling.

### Fast finality and user experience

Finality time impacts how quickly users and apps can treat transactions as ‚Äúdone.‚Äù Sei‚Äôs ~400ms finality supports near-instant confirmations for use cases that are sensitive to latency, such as trading, gaming, and real-time applications.

### Parallelization for throughput

Many blockchains execute transactions sequentially, which can limit throughput when demand spikes. Sei is built to **parallelize execution** where possible‚Äîallowing independent transactions (those that don‚Äôt touch the same state) to run concurrently. This improves capacity without requiring applications to move to a separate chain.

### EVM compatibility

Sei‚Äôs EVM support means developers can deploy contracts written in Solidity and integrate with familiar tooling (wallets, libraries, frameworks). This lowers the barrier for Ethereum developers to build on a fast L1 environment.

#### Example: Simple Solidity contract (EVM)

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

contract Counter {
    uint256 public value;

    function increment() external {
        value += 1;
    }
}
```

#### Example: Reading state with ethers (TypeScript)

```typescript
import { ethers } from 'ethers';

const rpcUrl = process.env.RPC_URL!; // Sei EVM RPC endpoint
const provider = new ethers.JsonRpcProvider(rpcUrl);

const counterAddress = '0xYourContractAddress';
const abi = ['function value() view returns (uint256)'];

async function main() {
  const counter = new ethers.Contract(counterAddress, abi, provider);
  const v = await counter.value();
  console.log('Counter value:', v.toString());
}

main().catch(console.error);
```

#### Example: Sending a transaction (TypeScript)

```typescript
import { ethers } from 'ethers';

const rpcUrl = process.env.RPC_URL!;
const privateKey = process.env.PRIVATE_KEY!;

const provider = new ethers.JsonRpcProvider(rpcUrl);
const wallet = new ethers.Wallet(privateKey, provider);

const counterAddress = '0xYourContractAddress';
const abi = ['function increment()'];

async function main() {
  const counter = new ethers.Contract(counterAddress, abi, wallet);
  const tx = await counter.increment();
  console.log('tx hash:', tx.hash);

  const receipt = await tx.wait();
  console.log('confirmed in block:', receipt.blockNumber);
}

main().catch(console.error);
```

## Why Layer 1 Blockchains Matter

Layer 1 blockchains are the foundation for decentralized applications and digital asset ecosystems. They define the security model, transaction finality, execution environment, and data availability that everything else depends on‚Äîwhile innovations like Sei‚Äôs parallelization, fast finality, and EVM compatibility push L1 performance toward real-time applications.

## Related Documentation

- [Getting Started](/learn)
- [Token Standards](/learn/dev-token-standards)
- [Staking](/learn/general-staking)
- [Oracles](/learn/oracles)

---

_Have a question that's not answered here? Join our [Discord](https://discord.gg/sei) community._
