---
title: 'What is Proof Of History and How Does It Secure the Blockchain?'
description: 'Learn about what is proof of history and how it works in blockchain and on Sei Network.'
keywords: ['sei', 'blockchain', 'glossary', 'what', 'proof', 'history', 'secure', 'blockchain']
---

import { Callout } from 'nextra/components';

export const jsonLd = {
  '@context': 'https://schema.org',
  '@graph': [
    {
      '@type': 'FAQPage',
      mainEntity: [
        {
          '@type': 'Question',
          name: 'What is Proof Of History and How Does It Secure the Blockchain?',
          acceptedAnswer: {
            '@type': 'Answer',
            text: 'Proof of History (PoH) is a cryptographic technique for creating a verifiable, ordered record of time between events on a blockchain. It works by producing a sequence of hashes where each output depends on the previous one, making the passage of ‚Äútime‚Äù (i.e., computation steps) auditable and hard to forge. PoH is typically paired with a separate consensus mechanism (such as Proof of Stake) to decide which blocks are final.'
          }
        }
      ]
    },
    {
      '@type': 'TechArticle',
      headline: 'What is Proof Of History and How Does It Secure the Blockchain?',
      description: 'Learn about what is proof of history and how it works in blockchain and on Sei Network.',
      author: {
        '@type': 'Organization',
        name: 'Sei Network',
        url: 'https://sei.io'
      },
      publisher: {
        '@type': 'Organization',
        name: 'Sei Network',
        url: 'https://sei.io'
      },
      about: {
        '@type': 'Thing',
        name: 'what is proof of history'
      },
      articleSection: 'glossary',
      inLanguage: 'en'
    }
  ]
};

<head>
  <script type="application/ld+json" dangerouslySetInnerHTML={{ __html: JSON.stringify(jsonLd) }} />
</head>

# What is Proof Of History and How Does It Secure the Blockchain?

<Callout type="info" emoji="ü§ñ">
  This content was generated with the assistance of AI and is intended for informational purposes only. Please verify all information independently before making decisions based on this content.
</Callout>

## Overview

Proof of History (PoH) is a cryptographic technique for creating a verifiable, ordered record of time between events on a blockchain. It works by producing a sequence of hashes where each output depends on the previous one, making the passage of ‚Äútime‚Äù (i.e., computation steps) auditable and hard to forge. PoH is typically paired with a separate consensus mechanism (such as Proof of Stake) to decide which blocks are final.

## How It Works

### A verifiable ‚Äúclock‚Äù using sequential hashing

In distributed systems, nodes don‚Äôt share a perfect clock, and network delays make it hard to agree on when something happened. PoH addresses this by building a **hash chain**:

- Start from a seed value.
- Repeatedly compute a cryptographic hash: `h1 = H(seed)`, `h2 = H(h1)`, `h3 = H(h2)`, etc.
- Because each hash depends on the prior hash, the only way to produce `hn` is to perform the prior `n-1` steps in order.

This creates a **verifiable ordering**: anyone can check that a given hash is the result of applying the hash function the required number of times, and thus that certain events were recorded after earlier ones in that sequence.

### Timestamping events

To timestamp an event (e.g., a transaction batch), the system can incorporate event data at a specific point in the sequence, commonly by hashing the event into the running value:

- At step `k`, compute `hk = H(hk-1 || event)` (conceptually).
- This ‚Äúanchors‚Äù the event into the sequence, proving it occurred no later than that position.

### How PoH contributes to security

PoH strengthens security primarily by improving **ordering and auditability**, rather than replacing consensus:

- **Tamper evidence:** If an attacker tries to alter an event anchored at step `k`, they must recompute the chain from `k` onward, which is computationally expensive and easy to detect.
- **Deterministic ordering:** Nodes can agree on a consistent ordering of events without relying solely on wall-clock timestamps, reducing ambiguity and some classes of reordering attacks.
- **Faster block production pipelines:** A verifiable timeline can reduce coordination overhead between nodes, allowing higher throughput‚Äîwhile final safety still depends on the underlying consensus and validator set.

### What PoH is not

- PoH is **not** a standalone consensus algorithm in most designs. It does not by itself decide which fork is canonical or which blocks are final.
- PoH does **not** eliminate the need for validator voting or economic security; it complements them by making event ordering cheaper to verify.

## On Sei Network

Sei Network does **not** use Proof of History as its consensus mechanism. Sei is a high-performance Layer 1 with **fast finality (~400ms)**, strong throughput, and **EVM compatibility**, achieved through its consensus and execution design rather than a PoH-based clock.

Where PoH focuses on creating a verifiable sequence to help with ordering, Sei achieves low latency and scalable performance through:

- **Parallelization:** Sei is built to execute workloads efficiently by parallelizing where possible, helping it maintain high throughput under load.
- **Rapid finality:** Transactions reach finality quickly (around ~400ms), reducing the time window for reorg risk and improving UX for trading and other latency-sensitive applications.
- **EVM compatibility:** Developers can deploy Solidity contracts and use standard Ethereum tooling, while benefiting from Sei‚Äôs performance characteristics.

### Practical takeaway for builders

If your goal is **secure ordering plus high throughput**, PoH is one possible design pattern in the broader ecosystem. On Sei, similar end-user outcomes‚Äîfast confirmations, reliable ordering guarantees, and strong safety‚Äîcome from Sei‚Äôs consensus finality and parallelized execution model, without requiring a PoH component.

## Minimal illustrative example (hash-chain ‚Äúhistory‚Äù)

The snippet below demonstrates the _idea_ behind PoH: a sequential hash chain that is easy to verify but inherently sequential to produce.

```typescript
import { createHash } from 'crypto';

function sha256(data: Buffer | string) {
  return createHash('sha256').update(data).digest('hex');
}

// Build a simple "history" of N steps.
function buildHistory(seed: string, steps: number) {
  const history: string[] = [];
  let h = sha256(seed);

  for (let i = 0; i < steps; i++) {
    history.push(h);
    h = sha256(h); // sequential dependency
  }
  return history;
}

// "Anchor" an event at a specific point in the chain
function anchorEvent(prevHash: string, event: string) {
  return sha256(prevHash + '|' + event);
}

const seed = 'genesis-seed';
const hist = buildHistory(seed, 5);

const event = 'txBatch:12345';
const anchored = anchorEvent(hist[2], event);

console.log('Step 3 hash:', hist[2]);
console.log('Anchored event hash:', anchored);
```

This example does not implement a full PoH system (or consensus). It only shows the core property PoH relies on: **a computation sequence that proves ordering because each step depends on the last**.

## Summary

Proof of History provides a cryptographically verifiable way to establish the order of events by using a sequential hash chain, making timelines tamper-evident and easier to audit. It can improve performance and reduce coordination overhead, but it typically relies on a separate consensus protocol for finality and fork choice. Sei Network does not use PoH; instead, Sei delivers fast finality, high throughput, and EVM compatibility through its own consensus and parallelized execution architecture.

## Related Documentation

- [Getting Started](/learn)
- [Token Standards](/learn/dev-token-standards)
- [Staking](/learn/general-staking)
- [Oracles](/learn/oracles)

---

_Have a question that's not answered here? Join our [Discord](https://discord.gg/sei) community._
