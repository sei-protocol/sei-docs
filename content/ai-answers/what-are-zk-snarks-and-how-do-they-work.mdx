---
title: 'What Are zk-SNARKs and How Do They Work?'
description: 'Learn about what is zk-SNARKs and how it works in blockchain and on Sei Network.'
keywords: ['sei', 'blockchain', 'glossary', 'what', 'zk-SNARKs', 'are', 'snarks', 'and', 'how', 'they', 'work']
---

import { Callout } from 'nextra/components';

# What Are zk-SNARKs and How Do They Work?

## Overview

zk-SNARKs (Zero-Knowledge Succinct Non-Interactive Arguments of Knowledge) are cryptographic proofs that let someone prove a statement is true without revealing the underlying data (zero-knowledge), with proofs that are small (succinct) and can be verified quickly, typically without back-and-forth communication (non-interactive). If you’re searching **“what is zk-SNARKs”**, the simplest definition is: a way to prove correctness privately and efficiently.

They’re widely used in blockchains for privacy-preserving transactions and for scalability via verifiable computation (proving that off-chain work was done correctly).

## How It Works

### Zero-knowledge proof basics

A zero-knowledge proof involves:

- **Prover**: generates a proof that a statement is true (e.g., “I know valid inputs that satisfy this program/constraint system”).
- **Verifier**: checks the proof’s validity without learning the secret inputs.

In a blockchain setting, the statement is often: “This transaction/state transition follows the rules,” while keeping sensitive data hidden.

### The “SNARK” properties

zk-SNARKs add specific properties that make them practical for blockchains:

- **Succinct**: proofs are small (often a few hundred bytes) and verification is fast.
- **Non-interactive**: the prover sends a single proof; the verifier checks it once.
- **Argument of knowledge**: a valid proof implies the prover “knows” a valid witness (the secret inputs) under standard cryptographic assumptions.

### High-level pipeline

1. **Define a computation**  
   Express the rule you want to prove as a circuit/constraint system (e.g., arithmetic constraints).  
   Examples: “balances don’t go negative,” “signature is valid,” “hash preimage exists.”

2. **Generate keys (setup phase in many SNARKs)**  
   Many zk-SNARK systems require a **trusted setup** to produce:

   - **Proving key (PK)**: used to generate proofs.
   - **Verification key (VK)**: used to verify proofs.  
     (Some modern proof systems reduce or remove trusted setup requirements, but “zk-SNARK” commonly refers to setup-based SNARKs.)

3. **Prove**  
   The prover takes:

   - **Public inputs**: values the verifier can see (e.g., commitment, Merkle root, output hash).
   - **Private inputs (“witness”)**: secret values (e.g., sender’s key, amounts, preimage).  
     Then generates a proof `π` that the constraints are satisfied.

4. **Verify**  
   The verifier checks `π` using the VK and the public inputs. If verification succeeds, the blockchain can accept the transaction or state update without seeing the private data.

### What zk-SNARKs are used for in blockchains

- **Privacy**: hide amounts, addresses, or other transaction details while still enforcing validity.
- **Scalability / verifiable compute**: prove that complex computation happened off-chain and post only a proof on-chain (common in rollups and other L2 designs).

## On Sei Network

Sei is a high-performance Layer 1 with **EVM compatibility**, **parallelization**, and ~**400ms finality**. zk-SNARK-based applications on Sei benefit from:

- **Fast settlement**: once a zk-proof is verified in a block, Sei’s low-latency finality helps zk-based apps reach finality quickly.
- **EVM compatibility**: zk verification can be implemented in Solidity using pairings/elliptic-curve precompiles where available (depending on the curve and scheme), enabling Ethereum-style zk-verifier contracts to be deployed on Sei.
- **Parallel execution**: Sei’s parallelization can improve throughput for workloads around proof submission, state updates, and associated transactions—especially when many users submit proofs concurrently—while verification itself remains a deterministic on-chain computation.

Typical Sei zk-SNARK integration patterns include:

- **On-chain verifier contract**: users post a proof; the contract verifies it and updates state (e.g., mint, withdraw, or register).
- **ZK-enabled apps**: privacy-preserving credentials, attestations, or compliance checks (prove “I’m eligible” without revealing identity).
- **ZK rollup-style bridges/appchains**: post proofs of off-chain state transitions for secure settlement on Sei (architecture-dependent).

## Example: Verifying a zk-SNARK Proof in Solidity (Conceptual)

Most zk-SNARK deployments on EVM chains use an autogenerated verifier contract (e.g., for Groth16) produced by tooling like circom/snarkjs or other ecosystems. The verifier typically exposes a function like `verifyProof`.

```solidity
// Conceptual interface; actual verifier code is usually autogenerated.
interface IVerifier {
    function verifyProof(
        uint256[2] calldata a,
        uint256[2][2] calldata b,
        uint256[2] calldata c,
        uint256[] calldata publicInputs
    ) external view returns (bool);
}

contract ZkGate {
    IVerifier public verifier;

    constructor(address _verifier) {
        verifier = IVerifier(_verifier);
    }

    function submitProof(
        uint256[2] calldata a,
        uint256[2][2] calldata b,
        uint256[2] calldata c,
        uint256[] calldata publicInputs
    ) external {
        require(verifier.verifyProof(a, b, c, publicInputs), "Invalid proof");

        // If proof is valid, perform state change (mint, unlock, register, etc.)
        // ...
    }
}
```

> Note: The exact proof format depends on the proving system (e.g., Groth16, PLONK variants), curve choice, and the verifier implementation used on Sei’s EVM.

## Developer Workflow (Typical)

A common zk-SNARK workflow looks like:

1. Write a circuit (constraints).
2. Generate proving/verifying keys (setup).
3. Generate proofs off-chain.
4. Deploy verifier on-chain.
5. Submit proofs to update on-chain state.

Tooling varies, but a “proof generation then on-chain verification” flow often resembles:

```bash
# 1) Compile circuit (example tooling)
circom circuit.circom --r1cs --wasm --sym

# 2) Setup (scheme-dependent; often generates proving/verification keys)
snarkjs groth16 setup circuit.r1cs pot.ptau circuit_0000.zkey
snarkjs zkey export verificationkey circuit_0000.zkey verification_key.json

# 3) Create witness + proof
node circuit_js/generate_witness.js circuit_js/circuit.wasm input.json witness.wtns
snarkjs groth16 prove circuit_0000.zkey witness.wtns proof.json public.json

# 4) Export Solidity verifier (if supported by tooling)
snarkjs zkey export solidityverifier circuit_0000.zkey Verifier.sol
```

## Key Benefits and Tradeoffs

### Benefits

- **Strong privacy guarantees**: prove correctness without revealing secrets.
- **Efficient verification**: small proofs and quick checks enable on-chain practicality.
- **Composable logic**: can enforce complex constraints with minimal on-chain data.

### Tradeoffs

- **Circuit complexity**: translating programs into constraints can be difficult and performance-sensitive.
- **Setup requirements**: many zk-SNARKs require trusted setup; mismanagement can undermine security (depending on the scheme).
- **Prover cost**: generating proofs can be computationally heavy, often done off-chain with specialized optimization.

## Related Terms

- **Zero-knowledge proofs (ZKPs)**: the broader category.
- **zk-STARKs**: often transparent setup and different performance tradeoffs (usually larger proofs).
- **Commitments / Merkle trees**: commonly used as public inputs to prove membership or correctness without revealing data.
- **Rollups / Validity proofs**: L2 patterns that use ZK proofs to scale throughput while retaining L1 security.

## Related Documentation

- [Getting Started](/learn)
- [Token Standards](/learn/dev-token-standards)
- [Staking](/learn/general-staking)
- [Oracles](/learn/oracles)

---

_Have a question that's not answered here? Join our [Discord](https://discord.gg/sei) community._
