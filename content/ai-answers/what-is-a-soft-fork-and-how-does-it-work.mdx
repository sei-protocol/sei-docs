---
title: 'What is a Soft Fork and How Does It Work?'
description: 'Learn about what is soft fork and how it works in blockchain and on Sei Network.'
keywords: ['sei', 'blockchain', 'glossary', 'what', 'soft', 'fork']
---

import { Callout } from 'nextra/components';

export const jsonLd = {
  '@context': 'https://schema.org',
  '@graph': [
    {
      '@type': 'FAQPage',
      mainEntity: [
        {
          '@type': 'Question',
          name: 'What is a Soft Fork and How Does It Work?',
          acceptedAnswer: {
            '@type': 'Answer',
            text: 'A soft fork is a backward-compatible change to a blockchain‚Äôs consensus rules that makes the rules more restrictive. After a soft fork activates, blocks that follow the new rules are still considered valid by nodes that haven‚Äôt upgraded, as long as the blocks also satisfy the old rules. This allows networks to upgrade with less risk of splitting into two permanent chains‚Äîprovided the upgrade achieves sufficient adoption.'
          }
        }
      ]
    },
    {
      '@type': 'TechArticle',
      headline: 'What is a Soft Fork and How Does It Work?',
      description: 'Learn about what is soft fork and how it works in blockchain and on Sei Network.',
      author: {
        '@type': 'Organization',
        name: 'Sei Network',
        url: 'https://sei.io'
      },
      publisher: {
        '@type': 'Organization',
        name: 'Sei Network',
        url: 'https://sei.io'
      },
      about: {
        '@type': 'Thing',
        name: 'what is soft fork'
      },
      articleSection: 'glossary',
      inLanguage: 'en'
    }
  ]
};

<head>
  <script type="application/ld+json" dangerouslySetInnerHTML={{ __html: JSON.stringify(jsonLd) }} />
</head>

# What is a Soft Fork and How Does It Work?

<Callout type="info" emoji="ü§ñ">
  This content was generated with the assistance of AI and is intended for informational purposes only. Please verify all information independently before making decisions based on this content.
</Callout>

## Overview

A **soft fork** is a backward-compatible change to a blockchain‚Äôs consensus rules that makes the rules **more restrictive**. After a soft fork activates, blocks that follow the new rules are still considered valid by nodes that haven‚Äôt upgraded, as long as the blocks also satisfy the old rules. This allows networks to upgrade with less risk of splitting into two permanent chains‚Äîprovided the upgrade achieves sufficient adoption.

## How It Works

### Backward compatibility (the core idea)

Consensus rules define what counts as a valid block and valid transactions. A soft fork tightens these rules‚Äîmeaning it _removes_ previously allowed behavior rather than adding new allowances.

- **Old nodes (not upgraded):** Continue to accept blocks produced under the new stricter rules because those blocks still conform to the old rules.
- **Upgraded nodes:** Enforce the new stricter rules and will reject blocks/transactions that violate them.

A common mental model:

- **Before:** Valid set of blocks = **A**
- **After soft fork:** Valid set of blocks = **B**, where **B ‚äÇ A** (B is a subset of A)

### Activation and enforcement

Soft forks typically require coordinated activation so the network transitions safely.

Common mechanisms include:

- **Miner/validator signaling:** Block producers signal readiness (e.g., via version bits or on-chain flags). Once signaling crosses a threshold, the new rules activate at a specific height/time.
- **Flag-day (scheduled) activation:** Nodes begin enforcing new rules after a predetermined block height or timestamp.
- **Client upgrades + governance (chain-specific):** Some networks coordinate via governance proposals and scheduled upgrades.

Once activated, the new rules are only effective if **a majority of block production** follows them. If most producers enforce the new rules, blocks that violate the rules won‚Äôt be built or will be orphaned.

### What can soft forks do?

Soft forks are often used to:

- Restrict transaction formats (e.g., new script constraints)
- Add new validation rules that old nodes interpret as ‚Äúanyone-can-spend‚Äù or otherwise compatible
- Fix certain classes of vulnerabilities by disallowing risky patterns

Soft forks generally **cannot** introduce changes that require old nodes to accept something previously invalid‚Äîthose changes are typically **hard forks**.

## On Sei Network

Sei Network is a high-performance Layer 1 with **EVM compatibility**, **parallelization**, and **~400ms finality**. In Sei‚Äôs ecosystem, changes to consensus or execution rules can be coordinated through planned network upgrades; whether a change is a ‚Äúsoft fork‚Äù depends on whether it is **backward-compatible and restrictive** at the consensus layer.

### Practical implications on Sei

- **Fast finality reduces uncertainty during upgrades:** With ~400ms finality, once blocks are finalized, reorg risk is minimized, which helps upgrades proceed cleanly once activated.
- **Parallelized execution increases throughput but doesn‚Äôt change fork semantics:** Parallelization affects how transactions are executed efficiently; fork type is still determined by whether the _validity rules_ become more restrictive (soft fork) or incompatible (hard fork).
- **EVM compatibility considerations:** If a change alters EVM execution or opcode semantics in a way that makes previously valid transactions invalid under stricter rules, it could be structured as a soft fork _only if_ non-upgraded nodes still accept the resulting blocks under their legacy validation rules. Most EVM-level behavior changes are not purely ‚Äúrestrictive‚Äù at the consensus layer and may require coordinated upgrades.

### Example: enforcing a new restriction (conceptual)

A soft-fork-like change on an EVM chain might be a new consensus rule that **rejects a specific transaction pattern** (e.g., disallowing certain malformed transactions) while still producing blocks that legacy nodes consider valid. Whether that‚Äôs feasible depends on how legacy validation is implemented and how blocks are verified.

## Example: Detecting chain upgrades in EVM applications

Even though forks are consensus-level events, dApps and tooling often want to detect network configuration changes (e.g., chain ID, hardfork rules in clients, or upgrade height) to avoid assumptions.

### TypeScript (RPC example)

```typescript
import { ethers } from 'ethers';

async function printNetworkInfo(rpcUrl: string) {
  const provider = new ethers.JsonRpcProvider(rpcUrl);
  const network = await provider.getNetwork();
  const blockNumber = await provider.getBlockNumber();

  console.log('chainId:', network.chainId.toString());
  console.log('latest block:', blockNumber);
}

printNetworkInfo('https://YOUR_SEI_EVM_RPC_URL');
```

### Bash (basic RPC calls)

```bash
curl -s -X POST https://YOUR_SEI_EVM_RPC_URL \
  -H "content-type: application/json" \
  --data '{"jsonrpc":"2.0","id":1,"method":"eth_chainId","params":[]}' | jq

curl -s -X POST https://YOUR_SEI_EVM_RPC_URL \
  -H "content-type: application/json" \
  --data '{"jsonrpc":"2.0","id":1,"method":"eth_blockNumber","params":[]}' | jq
```

## Key Takeaways

- A **soft fork** tightens consensus rules and is **backward-compatible**: upgraded nodes reject more things, but old nodes can still follow the chain.
- Successful soft forks require sufficient adoption by **block producers** so invalid (under new rules) blocks aren‚Äôt finalized.
- On Sei Network, upgrade coordination benefits from **~400ms finality** and high-performance execution, while the definition of ‚Äúsoft fork‚Äù remains rooted in whether consensus validity rules are restrictive and backward-compatible.

## Related Documentation

- [Getting Started](/learn)
- [Token Standards](/learn/dev-token-standards)
- [Staking](/learn/general-staking)
- [Oracles](/learn/oracles)

---

_Have a question that's not answered here? Join our [Discord](https://discord.gg/sei) community._
