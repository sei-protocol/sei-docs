---
title: 'What is Blockchain and How Does It Work?'
description: 'Learn about what is blockchain and how it works in blockchain and on Sei Network.'
keywords: ['sei', 'blockchain', 'glossary', 'what', 'blockchain']
---

import { Callout } from 'nextra/components';

export const jsonLd = {
  '@context': 'https://schema.org',
  '@graph': [
    {
      '@type': 'FAQPage',
      mainEntity: [
        {
          '@type': 'Question',
          name: 'What is Blockchain and How Does It Work?',
          acceptedAnswer: {
            '@type': 'Answer',
            text: 'A blockchain is a distributed database that records transactions in a sequence of ‚Äúblocks‚Äù linked together with cryptography, creating a tamper-evident history. Instead of relying on a single central server, multiple independent nodes maintain the same ledger and agree on updates through a consensus mechanism. This design makes blockchain systems transparent, resilient, and difficult to alter without detection.'
          }
        }
      ]
    },
    {
      '@type': 'TechArticle',
      headline: 'What is Blockchain and How Does It Work?',
      description: 'Learn about what is blockchain and how it works in blockchain and on Sei Network.',
      author: {
        '@type': 'Organization',
        name: 'Sei Network',
        url: 'https://sei.io'
      },
      publisher: {
        '@type': 'Organization',
        name: 'Sei Network',
        url: 'https://sei.io'
      },
      about: {
        '@type': 'Thing',
        name: 'what is blockchain'
      },
      articleSection: 'glossary',
      inLanguage: 'en'
    }
  ]
};

<head>
  <script type="application/ld+json" dangerouslySetInnerHTML={{ __html: JSON.stringify(jsonLd) }} />
</head>

# What is Blockchain and How Does It Work?

<Callout type="info" emoji="ü§ñ">
  This content was generated with the assistance of AI and is intended for informational purposes only. Please verify all information independently before making decisions based on this content.
</Callout>

## Overview

A blockchain is a distributed database that records transactions in a sequence of ‚Äúblocks‚Äù linked together with cryptography, creating a tamper-evident history. Instead of relying on a single central server, multiple independent nodes maintain the same ledger and agree on updates through a consensus mechanism. This design makes blockchain systems transparent, resilient, and difficult to alter without detection.

## How It Works

### 1) Transactions and state changes

Users submit **transactions** (e.g., sending tokens, swapping assets, calling a smart contract). Each transaction describes a change to the blockchain‚Äôs **state**‚Äîaccount balances, contract storage, and other on-chain data.

### 2) Blocks: batching transactions

Nodes collect valid transactions into a **block**. A block typically contains:

- A list of transactions
- A reference to the previous block (via its hash)
- Metadata (timestamp, proposer/validator info, etc.)
- A state commitment (e.g., a root hash representing the resulting state)

Because each block references the previous block‚Äôs hash, blocks form a **chain**. If someone tries to modify an old transaction, that block‚Äôs hash changes and breaks the linkage to all subsequent blocks‚Äîmaking tampering obvious.

### 3) Cryptographic hashing and linkage

A **hash** is a one-way function that maps data to a fixed-length value. Blockchains use hashes to:

- Link blocks together (previous block hash)
- Verify data integrity (small changes produce drastically different hashes)
- Commit to large datasets efficiently (via Merkle trees or similar structures)

### 4) Consensus: agreeing on the next block

Since there‚Äôs no central authority, nodes must agree on which transactions are included and in what order. This is handled by **consensus**, commonly:

- **Proof of Work (PoW):** miners solve computational puzzles to propose blocks (energy-intensive)
- **Proof of Stake (PoS):** validators stake assets and participate in block proposal/finality (typically more energy-efficient)

Consensus ensures that honest participants converge on a single canonical chain and that reversing finalized history is economically or computationally prohibitive.

### 5) Validation and finality

When a node receives a proposed block, it:

- Verifies transaction signatures and rules (e.g., balances, nonces)
- Executes smart contract code (if applicable)
- Checks that the proposed state transition is valid

Depending on the chain, a block may become **final** (effectively irreversible) after a certain confirmation process. Finality can be probabilistic (common in PoW) or deterministic/fast (common in many PoS designs).

### 6) Smart contracts (programmable blockchains)

Many blockchains support **smart contracts**‚Äîprograms deployed on-chain that execute deterministically. Users interact with contracts via transactions, enabling decentralized applications (DeFi, NFTs, games, identity, and more).

Example (Solidity smart contract snippet):

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

contract SimpleCounter {
    uint256 public count;

    function increment() external {
        count += 1;
    }
}
```

## On Sei Network

Sei is a high-performance Layer 1 blockchain designed for fast, scalable execution and supports **EVM compatibility**, allowing Solidity smart contracts and Ethereum tooling to work with minimal changes. Sei emphasizes throughput and user experience through **parallelization** (processing independent transactions concurrently) and delivers **~400ms finality**, meaning transactions can become final extremely quickly compared to many networks.

### Parallel execution and scalability

In many blockchains, transactions are executed largely in sequence, which can limit throughput during high demand. Sei‚Äôs architecture is built to better utilize parallelism by executing transactions concurrently when they don‚Äôt contend for the same state‚Äîimproving performance for workloads like trading, gaming, and high-frequency interactions.

### Fast finality (~400ms)

Fast finality reduces:

- User wait times for confirmations
- Risk and cost of reorg-sensitive workflows
- Latency for applications like exchanges, markets, and on-chain order matching

From a developer perspective, faster finality can enable smoother UX (near-instant transaction completion) and tighter feedback loops for on-chain actions.

### EVM compatibility

Because Sei supports EVM execution, developers can:

- Write contracts in **Solidity**
- Use familiar tools like **Hardhat**, **Foundry**, and **ethers.js**
- Port many Ethereum-based applications with minimal adjustments (while benefiting from Sei‚Äôs performance characteristics)

Example (TypeScript with ethers.js to send a transaction on an EVM chain like Sei):

```typescript
import { ethers } from 'ethers';

const rpcUrl = process.env.RPC_URL!;
const privateKey = process.env.PRIVATE_KEY!;

async function main() {
  const provider = new ethers.JsonRpcProvider(rpcUrl);
  const wallet = new ethers.Wallet(privateKey, provider);

  const tx = await wallet.sendTransaction({
    to: '0x0000000000000000000000000000000000000000',
    value: ethers.parseEther('0.001')
  });

  console.log('tx hash:', tx.hash);
  const receipt = await tx.wait();
  console.log('status:', receipt?.status);
}

main().catch(console.error);
```

### Why it matters for users and builders

On Sei, blockchain fundamentals‚Äîdistributed verification, cryptographic integrity, and consensus-backed finality‚Äîare combined with infrastructure aimed at high throughput and low latency. This makes Sei well-suited for applications that need the security and transparency of blockchain, but also demand real-time performance and EVM developer compatibility.

## Related Documentation

- [Getting Started](/learn)
- [Token Standards](/learn/dev-token-standards)
- [Staking](/learn/general-staking)
- [Oracles](/learn/oracles)

---

_Have a question that's not answered here? Join our [Discord](https://discord.gg/sei) community._
