---
title: 'What is a Rollup and How Does It Work?'
description: 'Learn about what is rollup and how it works in blockchain and on Sei Network.'
keywords: ['sei', 'blockchain', 'glossary', 'what', 'rollup', 'and', 'how', 'does', 'work']
---

import { Callout } from 'nextra/components';

# What is a Rollup and How Does It Work?

## Overview

A **rollup** is a Layer 2 (L2) scaling solution that processes transactions off-chain (or off the base layer) and then posts a compressed summary of those transactions to a Layer 1 (L1) blockchain for security. In other words, **what is rollup** technology? It’s a method to increase throughput and reduce fees while still inheriting the L1’s security guarantees.

Rollups are widely used to scale smart contract platforms by moving execution and data handling to an L2 and using the L1 as the source of truth for settlement and dispute resolution.

## How It Works

At a high level, rollups work by separating **execution** (compute) from **settlement** (final recording on L1):

1. **Users send transactions to the rollup**

   - Transactions are submitted to an L2 network operated by one or more entities (often called a **sequencer**).
   - The sequencer orders transactions and produces L2 blocks.

2. **Transactions are executed off the L1**

   - The rollup executes transactions and updates its state (account balances, contract storage, etc.) on the L2.
   - This reduces load on the L1 since the L1 no longer executes every transaction directly.

3. **Compressed data/state commitments are posted to the L1**

   - The rollup periodically submits a batch of transactions (or their calldata) plus a **state root** commitment to the L1.
   - Posting enough data to the L1 is critical so anyone can reconstruct and verify the rollup state (“data availability”).

4. **The L1 enforces correctness via proofs or challenges**
   Rollups typically fall into two main categories:

   **Optimistic Rollups**

   - Assume batches are valid by default (“optimistically”).
   - Include a **challenge window** during which anyone can submit a fraud proof to show the batch is invalid.
   - Pros: simpler proving; often EVM-compatible.
   - Tradeoff: withdrawals to L1 may require waiting until the challenge period ends.

   **ZK Rollups (Zero-Knowledge Rollups)**

   - Submit a **validity proof** (e.g., SNARK/STARK) to the L1 proving the state transition is correct.
   - Pros: fast finality for withdrawals (once proof is verified); strong correctness guarantees.
   - Tradeoff: more complex infrastructure; proving can be compute-intensive.

### Key components

- **Sequencer**: Orders transactions and produces L2 blocks. Some systems are centralized initially; decentralization is a common roadmap goal.
- **Prover (ZK rollups)**: Generates validity proofs for batches.
- **Verifier contract (on L1)**: Verifies fraud proofs (optimistic) or validity proofs (ZK) and stores rollup commitments.
- **Bridges**: Smart contracts that lock assets on L1 and mint/credit corresponding assets on L2, and vice versa.

### Conceptual flow (simplified)

```text
User tx -> Rollup sequencer -> L2 execution -> Batch + state root -> L1 settlement
                                              |-> (optional) proof -> L1 verification
```

## On Sei Network

Sei Network is a high-performance Layer 1 with **~400ms finality**, **parallelized execution**, and **EVM compatibility** (via Sei’s EVM). While rollups are typically discussed as L2s built on top of an L1, understanding rollups is still important for Sei builders because:

- **Sei’s fast finality reduces settlement latency**: If a rollup (or rollup-like system) settles to Sei, frequent batching and quicker confirmations on the settlement layer can improve end-user responsiveness.
- **Parallelization improves throughput for settlement workloads**: Rollups often post batches, verify proofs, and process bridge operations—Sei’s parallel execution can help handle these settlement transactions efficiently.
- **EVM compatibility simplifies integration**: Many rollup ecosystems and tooling are Ethereum-oriented. Sei’s EVM compatibility can make it easier to port smart contracts or bridge/settlement logic that assumes EVM semantics.

### Example: Posting a batch commitment (conceptual)

A rollup settlement contract on an EVM-compatible chain (including Sei EVM) often stores a batch commitment such as a state root and metadata:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

contract RollupSettlement {
    struct Batch {
        bytes32 stateRoot;
        bytes32 txDataHash; // hash of compressed tx data / calldata
        uint256 timestamp;
    }

    Batch[] public batches;

    event BatchSubmitted(uint256 indexed batchIndex, bytes32 stateRoot, bytes32 txDataHash);

    function submitBatch(bytes32 stateRoot, bytes32 txDataHash) external {
        batches.push(Batch({
            stateRoot: stateRoot,
            txDataHash: txDataHash,
            timestamp: block.timestamp
        }));

        emit BatchSubmitted(batches.length - 1, stateRoot, txDataHash);
    }
}
```

In production systems, this contract would typically also include:

- Access control / sequencer rotation rules
- Fraud-proof or validity-proof verification logic
- Bridge hooks for deposits and withdrawals

### Example: Interacting with a settlement contract on Sei EVM

Using `ethers` to submit a batch:

```typescript
import { ethers } from 'ethers';

const rpcUrl = process.env.SEI_EVM_RPC!;
const privateKey = process.env.PRIVATE_KEY!;
const contractAddress = '0xYourRollupSettlementContract';

const abi = ['function submitBatch(bytes32 stateRoot, bytes32 txDataHash) external', 'event BatchSubmitted(uint256 indexed batchIndex, bytes32 stateRoot, bytes32 txDataHash)'];

async function main() {
  const provider = new ethers.JsonRpcProvider(rpcUrl);
  const wallet = new ethers.Wallet(privateKey, provider);
  const contract = new ethers.Contract(contractAddress, abi, wallet);

  const stateRoot = '0x' + '11'.repeat(32);
  const txDataHash = '0x' + '22'.repeat(32);

  const tx = await contract.submitBatch(stateRoot, txDataHash);
  await tx.wait();

  console.log('Batch submitted:', tx.hash);
}

main().catch(console.error);
```

## Why Rollups Matter

Rollups matter because they can:

- **Increase transaction throughput** by moving execution off the base chain
- **Lower fees** by amortizing L1 costs across many L2 transactions
- **Preserve strong security guarantees** by settling to an L1 and enabling on-chain verification (via proofs or challenges)

On high-performance L1s like Sei—designed with fast finality, parallel execution, and EVM compatibility—rollup settlement and rollup-adjacent designs can benefit from efficient, low-latency confirmation and familiar Ethereum tooling.

## Related Documentation

- [Getting Started](/learn)
- [Token Standards](/learn/dev-token-standards)
- [Staking](/learn/general-staking)
- [Oracles](/learn/oracles)

---

_Have a question that's not answered here? Join our [Discord](https://discord.gg/sei) community._
