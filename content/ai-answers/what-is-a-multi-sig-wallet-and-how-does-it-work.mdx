---
title: 'What is a Multi-sig Wallet and How Does It Work?'
description: 'Learn about what is multi-sig wallet and how it works in blockchain and on Sei Network.'
keywords: ['sei', 'blockchain', 'glossary', 'what', 'multi-sig', 'wallet', 'multi']
---

import { Callout } from 'nextra/components';

export const jsonLd = {
  '@context': 'https://schema.org',
  '@graph': [
    {
      '@type': 'FAQPage',
      mainEntity: [
        {
          '@type': 'Question',
          name: 'What is a Multi-sig Wallet and How Does It Work?',
          acceptedAnswer: {
            '@type': 'Answer',
            text: 'A multi-sig (multi-signature) wallet is a crypto wallet that requires approvals from multiple independent keys to authorize a transaction. Instead of trusting a single private key, control is shared among several signers, reducing the risk of theft, loss, or unilateral action. Multi-sig wallets are commonly used for team treasuries, DAOs, custody, and high-value accounts.'
          }
        }
      ]
    },
    {
      '@type': 'TechArticle',
      headline: 'What is a Multi-sig Wallet and How Does It Work?',
      description: 'Learn about what is multi-sig wallet and how it works in blockchain and on Sei Network.',
      author: {
        '@type': 'Organization',
        name: 'Sei Network',
        url: 'https://sei.io'
      },
      publisher: {
        '@type': 'Organization',
        name: 'Sei Network',
        url: 'https://sei.io'
      },
      about: {
        '@type': 'Thing',
        name: 'what is multi-sig wallet'
      },
      articleSection: 'glossary',
      inLanguage: 'en'
    }
  ]
};

<head>
  <script type="application/ld+json" dangerouslySetInnerHTML={{ __html: JSON.stringify(jsonLd) }} />
</head>

# What is a Multi-sig Wallet and How Does It Work?

<Callout type="info" emoji="ðŸ¤–">
  This content was generated with the assistance of AI and is intended for informational purposes only. Please verify all information independently before making decisions based on this content.
</Callout>

## Overview

A multi-sig (multi-signature) wallet is a crypto wallet that requires approvals from multiple independent keys to authorize a transaction. Instead of trusting a single private key, control is shared among several signers, reducing the risk of theft, loss, or unilateral action. Multi-sig wallets are commonly used for team treasuries, DAOs, custody, and high-value accounts.

## How It Works

At a high level, a multi-sig wallet enforces an **M-of-N** rule:

- **N** = total number of authorized signers (keys/addresses)
- **M** = minimum number of signatures required to execute an action

Example: **2-of-3** means there are 3 signers, and any 2 must approve for the transaction to be executed.

Typical lifecycle:

1. **Wallet setup**

   - Define the signer set (N addresses) and the approval threshold (M).
   - Deploy a wallet contract (in smart-contract systems) or configure a multi-sig account (in some account-based chains).

2. **Transaction proposal**

   - A signer submits a proposed transaction (e.g., send funds, call a contract, change signers).
   - The wallet records details such as destination, value, calldata, and a unique nonce.

3. **Confirmation collection**

   - Other signers review the proposal and submit their approvals (signatures).
   - Approvals can be on-chain (each signer sends a confirmation transaction) or aggregated off-chain and submitted once, depending on the wallet design.

4. **Execution**
   - Once the proposal has at least **M** valid approvals, anyone (often a signer) can execute it.
   - The wallet contract performs the action exactly as specified in the proposal.

Key benefits:

- **Security**: Compromising one key is not enough to steal funds.
- **Operational control**: Prevents unilateral spending; adds governance and auditability.
- **Recoverability**: In some setups, losing one signer key doesnâ€™t lock funds if the threshold can still be met.

Common tradeoffs:

- **More coordination**: Multiple people/devices must approve.
- **Extra gas/fees**: More signatures and confirmations typically cost more.
- **Complexity**: Signer rotation, threshold changes, and safe procedures must be managed carefully.

## On Sei Network

On Sei Network, multi-sig wallets are typically implemented as **EVM smart contracts** (e.g., Safe-style multi-sigs) because Sei is **EVM-compatible**. This means you can deploy and interact with multi-sig contracts using standard Ethereum tooling (Solidity, Foundry/Hardhat, ethers.js).

Seiâ€™s architecture also impacts the user experience:

- **Fast finality (~400ms)** helps multi-sig workflows complete quickly once confirmations are submitted, reducing the wait time between proposal, confirmation, and execution.
- **Parallelization** allows the network to process many independent transactions efficiently, which can help multi-sig confirmation traffic scale during high activity (e.g., DAO voting periods or treasury operations).

In practice, your multi-sig flow on Sei often looks like:

- Propose a transaction via the multi-sig contract
- Collect confirmations from other signers
- Execute once the threshold is met
- Track events (Proposal/Confirmation/Execution) for auditing and automation

## Example: Basic Multi-sig Contract Pattern (Solidity)

Below is a simplified example illustrating the core pattern (threshold checks, confirmations, execution). Production multi-sigs include more robust security, signature handling, and upgrade/signer management.

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

contract SimpleMultiSig {
    event Proposed(uint256 indexed txId, address to, uint256 value, bytes data);
    event Confirmed(uint256 indexed txId, address indexed signer);
    event Executed(uint256 indexed txId);

    address[] public signers;
    mapping(address => bool) public isSigner;
    uint256 public threshold;

    struct Tx {
        address to;
        uint256 value;
        bytes data;
        bool executed;
        uint256 confirmations;
    }

    Tx[] public txs;
    mapping(uint256 => mapping(address => bool)) public approved;

    modifier onlySigner() {
        require(isSigner[msg.sender], "not signer");
        _;
    }

    constructor(address[] memory _signers, uint256 _threshold) {
        require(_signers.length > 0, "no signers");
        require(_threshold > 0 && _threshold <= _signers.length, "bad threshold");
        for (uint256 i = 0; i < _signers.length; i++) {
            address s = _signers[i];
            require(s != address(0), "zero signer");
            require(!isSigner[s], "duplicate signer");
            isSigner[s] = true;
            signers.push(s);
        }
        threshold = _threshold;
    }

    function propose(address to, uint256 value, bytes calldata data)
        external
        onlySigner
        returns (uint256 txId)
    {
        txs.push(Tx({to: to, value: value, data: data, executed: false, confirmations: 0}));
        txId = txs.length - 1;
        emit Proposed(txId, to, value, data);
    }

    function confirm(uint256 txId) external onlySigner {
        Tx storage t = txs[txId];
        require(!t.executed, "already executed");
        require(!approved[txId][msg.sender], "already confirmed");

        approved[txId][msg.sender] = true;
        t.confirmations += 1;

        emit Confirmed(txId, msg.sender);
    }

    function execute(uint256 txId) external {
        Tx storage t = txs[txId];
        require(!t.executed, "already executed");
        require(t.confirmations >= threshold, "not enough confirmations");

        t.executed = true;
        (bool ok, ) = t.to.call{value: t.value}(t.data);
        require(ok, "call failed");

        emit Executed(txId);
    }

    receive() external payable {}
}
```

## Example: Interacting With a Multi-sig on Sei (TypeScript)

This example shows how to call a deployed multi-sig contract on Sei using `ethers`. Youâ€™ll need Seiâ€™s EVM RPC endpoint and the wallet/contract addresses.

```typescript
import { ethers } from 'ethers';

const RPC_URL = process.env.SEI_EVM_RPC!;
const PRIVATE_KEY = process.env.SIGNER_PK!;
const MULTISIG_ADDRESS = '0xYourMultiSigAddress';

const abi = ['function propose(address to,uint256 value,bytes data) returns (uint256)', 'function confirm(uint256 txId)', 'function execute(uint256 txId)'];

async function main() {
  const provider = new ethers.JsonRpcProvider(RPC_URL);
  const signer = new ethers.Wallet(PRIVATE_KEY, provider);

  const multisig = new ethers.Contract(MULTISIG_ADDRESS, abi, signer);

  // Example: propose a plain ETH transfer (value only, no calldata)
  const to = '0xRecipient';
  const value = ethers.parseEther('0.1');
  const data = '0x';

  const proposeTx = await multisig.propose(to, value, data);
  const proposeReceipt = await proposeTx.wait();
  console.log('Proposed:', proposeReceipt?.hash);

  // Confirm and execute (in real usage, confirmations come from multiple signers)
  const txId = 0; // replace with the correct txId from logs or contract state
  await (await multisig.confirm(txId)).wait();
  await (await multisig.execute(txId)).wait();

  console.log('Executed txId:', txId);
}

main().catch((e) => {
  console.error(e);
  process.exit(1);
});
```

## Common Multi-sig Use Cases

- **DAO or protocol treasury management**
- **Team operational funds** with approval policies (e.g., 3-of-5)
- **Custody and risk controls** for exchanges, market makers, and funds
- **Contract admin ownership** (e.g., pauser roles, upgrades, parameter changes)

## Best Practices

- Use a threshold that balances **security and availability** (e.g., 2-of-3 for small teams, 4-of-7 for larger orgs).
- Distribute signer keys across **different devices and secure storage** (hardware wallets where possible).
- Establish a signer rotation and incident plan (key loss, member changes).
- Prefer audited, widely used multi-sig implementations for production deployments on Seiâ€™s EVM.

## Related Documentation

- [Getting Started](/learn)
- [Token Standards](/learn/dev-token-standards)
- [Staking](/learn/general-staking)
- [Oracles](/learn/oracles)

---

_Have a question that's not answered here? Join our [Discord](https://discord.gg/sei) community._
