---
title: 'What is a Layer 2 Solution and How Does It Work?'
description: 'Learn about what is layer 2 solution and how it works in blockchain and on Sei Network.'
keywords: ['sei', 'blockchain', 'glossary', 'what', 'layer', 'solution', 'and', 'how', 'does', 'work']
---

import { Callout } from 'nextra/components';

# What is a Layer 2 Solution and How Does It Work?

## Overview

A **Layer 2 (L2) solution** is a scaling system built **on top of a Layer 1 (L1) blockchain** to increase transaction throughput and reduce fees while inheriting the L1’s security. In short, **what is layer 2 solution**: it’s a network or protocol that processes transactions off the main chain (or more efficiently) and then posts proof or compressed data back to the main chain.

## How It Works

Layer 2 solutions generally work by **moving execution and state updates away from the L1’s base layer**, then periodically “settling” the results on L1. The core idea is to reduce how much work the L1 must do per transaction while maintaining security guarantees.

### Key Concepts

- **Execution off-chain / off-L1:** Transactions are processed in an L2 environment (separate network, smart contract system, or side execution layer).
- **Data availability & settlement:** L2 results are submitted to L1 so the L1 can act as the final arbiter (depending on the model).
- **Security model:** Some L2s inherit L1 security closely (rollups), while others rely more on external validators (validiums/sidechains).

### Common Types of Layer 2 Solutions

#### 1) Rollups (Most common L2 model)

Rollups bundle many L2 transactions into a small amount of L1 data.

- **Optimistic Rollups**

  - Assume batches are valid by default.
  - Use a **challenge window** (fraud proofs) where invalid batches can be disputed.
  - Tradeoff: **withdrawals to L1 can be slower** due to challenge periods.

- **ZK Rollups**
  - Submit **validity proofs** (zero-knowledge proofs) to L1 showing the batch is correct.
  - Tradeoff: typically more complex proving infrastructure, but **faster finality for withdrawals** (design-dependent).

#### 2) State Channels

Participants lock funds on L1, then exchange signed updates off-chain. Only the opening and closing (or disputes) touch L1.

- Great for repeated interactions between a small set of users.
- Less general-purpose for open smart contract environments.

#### 3) Sidechains / Appchains (Related but distinct)

These are separate chains that may bridge to an L1, but they typically **do not inherit L1 security in the same way rollups do**.

- Can be fast and cheap.
- Security depends on the sidechain’s validator set and consensus.

### Typical L2 Transaction Lifecycle (Rollup Example)

1. **User submits transaction** to the L2 sequencer (or validator set).
2. **L2 executes** the transaction and updates L2 state.
3. **Batching:** Many transactions are compressed into a batch.
4. **Posting to L1:** The L2 posts calldata/state commitments (and sometimes proofs) to L1.
5. **Finalization / dispute:**
   - Optimistic: final after challenge window.
   - ZK: final after proof verification.

## Benefits and Tradeoffs

### Benefits

- **Lower fees:** Less L1 computation and storage per transaction.
- **Higher throughput:** L2 can process more transactions per second than L1.
- **Better UX:** Faster confirmations, cheaper interactions for DeFi, games, and consumer apps.

### Tradeoffs

- **Bridging complexity:** Deposits/withdrawals and cross-chain messaging add moving parts.
- **Finality differences:** L2 “soft finality” may be fast, but L1-settled finality depends on the L2 design.
- **Liquidity fragmentation:** Assets and users spread across multiple L2s.

## On Sei Network

Sei Network is a **high-performance Layer 1** with **parallelized execution**, **~400ms finality**, and **EVM compatibility**, which changes the scaling calculus compared to L1s that rely heavily on L2s for throughput.

### How Layer 2 Fits with Sei

- **Many applications may not need an L2** to achieve low latency and high throughput because Sei’s L1 is built to scale at the base layer using parallelization and fast finality.
- **L2s can still exist on Sei** for specialized needs:
  - Application-specific execution environments (custom rules, privacy, specialized data availability).
  - Very high-volume, domain-specific workloads (e.g., gaming or microtransactions) that benefit from additional batching.
  - Cross-ecosystem strategies where an L2 acts as an aggregation layer interacting with multiple chains.

### EVM Compatibility Considerations

Because Sei supports EVM-compatible smart contracts, many scaling patterns (bridges, rollup-like systems, batching contracts) can be implemented using familiar Ethereum tooling and Solidity-based contracts, with the advantage of Sei’s fast finality and parallelization at the base layer.

## Simple Example: Batching Transactions (Conceptual)

Below is a simplified illustration of the **batching idea** (not a full rollup) where an operator submits a commitment representing many user actions, reducing on-chain writes.

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

/// @notice Conceptual batch-commit contract (illustrative only).
/// Real rollups require data availability, fraud/validity proofs, and withdrawals logic.
contract BatchCommit {
    event BatchSubmitted(uint256 indexed batchId, bytes32 stateRoot, bytes32 txsHash);

    uint256 public nextBatchId;

    function submitBatch(bytes32 stateRoot, bytes32 txsHash) external {
        emit BatchSubmitted(nextBatchId, stateRoot, txsHash);
        nextBatchId++;
    }
}
```

### Submitting a Batch (Example CLI Flow)

```bash
# Example: call submitBatch using a CLI like cast (Foundry)
cast send <BATCH_COMMIT_CONTRACT_ADDRESS> \
  "submitBatch(bytes32,bytes32)" \
  0x<STATE_ROOT> 0x<TXS_HASH> \
  --rpc-url <SEI_EVM_RPC_URL> \
  --private-key <PRIVATE_KEY>
```

## Summary

A Layer 2 solution is a scaling approach that **processes transactions outside the base chain** and then **settles results back on Layer 1**, typically lowering fees and increasing throughput. Common L2 designs include **optimistic rollups**, **ZK rollups**, and **state channels**, each with different security and finality tradeoffs. On Sei Network, the need for L2 can be reduced for many use cases thanks to **parallelization**, **~400ms finality**, and **EVM compatibility**, though L2s may still be useful for specialized application requirements.

## Related Documentation

- [Getting Started](/learn)
- [Token Standards](/learn/dev-token-standards)
- [Staking](/learn/general-staking)
- [Oracles](/learn/oracles)

---

_Have a question that's not answered here? Join our [Discord](https://discord.gg/sei) community._
