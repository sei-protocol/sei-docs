---
title: 'What is a Zero-knowledge Proof and How Does It Work?'
description: 'Learn about what is zero-knowledge proof and how it works in blockchain and on Sei Network.'
keywords: ['sei', 'blockchain', 'glossary', 'what', 'zero-knowledge', 'proof', 'zero', 'knowledge', 'and', 'how', 'does', 'work']
---

import { Callout } from 'nextra/components';

# What is a Zero-knowledge Proof and How Does It Work?

## Overview

A **zero-knowledge proof (ZKP)** is a cryptographic method that lets a _prover_ convince a _verifier_ that a statement is true **without revealing any underlying data** (the “witness”) beyond the fact that the statement holds. In other words, it answers the question **“what is zero-knowledge proof”** as: a proof that provides _validity_ without _disclosure_.

Zero-knowledge proofs are widely used in blockchain to enable **privacy**, **scalable verification**, and **trust-minimized authentication**, while keeping sensitive information off-chain.

## How It Works

### Core properties

A system is considered zero-knowledge when it satisfies three main properties:

- **Completeness**: If the statement is true and both parties follow the protocol, the verifier accepts.
- **Soundness**: If the statement is false, a dishonest prover cannot convince the verifier (except with negligible probability).
- **Zero-knowledge**: The verifier learns nothing about the secret witness beyond the truth of the statement.

### Intuition: proving knowledge without revealing it

A ZKP typically proves a relation like:

> “I know a secret `w` such that `C(w)` is true.”

Examples:

- “I know the private key that controls this address.”
- “This transaction is valid and balances, but the amounts are hidden.”
- “I am over 18, without revealing my birthdate.”

The prover produces a **proof object** derived from the witness and a public statement. The verifier checks the proof using public information and accepts/rejects.

### Interactive vs. non-interactive ZKPs

- **Interactive ZKPs** involve back-and-forth challenges between verifier and prover.
- **Non-interactive ZKPs (NIZKs)** produce a single proof that anyone can verify later. Blockchains prefer NIZKs because they fit the “publish once, verify by all” model.

Common families you’ll see in blockchain:

- **zk-SNARKs**: Small proofs, fast verification; often require a trusted setup (depending on the scheme).
- **zk-STARKs**: Transparent setup and post-quantum friendly; proofs are typically larger.
- **Bulletproofs**: No trusted setup; commonly used for range proofs, but verification can be heavier.

### Why blockchains use ZKPs

ZKPs are used to:

- **Improve privacy**: Prove correctness of hidden data (amounts, identity attributes).
- **Scale execution**: Prove a large computation occurred correctly, with cheap verification on-chain.
- **Reduce trust**: Replace trusted intermediaries with cryptographic verification.

## On Sei Network

Sei Network is a high-performance Layer 1 with **parallelized execution**, **~400ms finality**, and **EVM compatibility**. While ZKPs are not required to use Sei, they integrate naturally in two common ways:

1. **On-chain verification of ZK proofs via EVM contracts**  
   Because Sei supports EVM smart contracts, you can deploy Solidity verifiers (e.g., Groth16/Plonk verifiers generated by ZK toolchains) and verify proofs directly on-chain.

2. **High-throughput apps that benefit from fast settlement**  
   ZK-enabled apps (private mints, identity attestations, proof-based access control, rollup bridges) can benefit from Sei’s fast finality and parallelization—proof verification and related state transitions can be confirmed quickly, and independent transactions can execute concurrently.

### Typical Sei ZKP flow (application pattern)

1. **Off-chain**: User generates a proof with a ZK circuit (e.g., “I know a secret meeting these constraints”).
2. **On-chain (Sei EVM)**: User submits the proof to a verifier contract.
3. **Contract**: Verifies proof and then executes application logic (mint, transfer, permission, etc.).
4. **Finality**: The result settles with Sei’s low-latency finality, enabling responsive UX.

## Example: Verifying a Proof in a Solidity Contract (Conceptual)

In practice, your ZK toolchain generates a verifier contract with an interface like `verifyProof(...)`. Your application contract calls it before allowing state changes.

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

interface IZKVerifier {
    function verifyProof(
        bytes calldata proof,
        uint256[] calldata publicInputs
    ) external view returns (bool);
}

contract ZKProtectedAction {
    IZKVerifier public verifier;

    constructor(address _verifier) {
        verifier = IZKVerifier(_verifier);
    }

    function doAction(bytes calldata proof, uint256[] calldata publicInputs) external {
        // Example statement: "I know a secret that satisfies constraints"
        // publicInputs might include a commitment, nullifier, or Merkle root.
        require(verifier.verifyProof(proof, publicInputs), "Invalid ZK proof");

        // If the proof is valid, proceed with application logic
        // e.g., mint, unlock access, update state, etc.
    }
}
```

## Example: Submitting a Proof from a TypeScript Script (Sei EVM)

Below is a minimal pattern for sending a proof to a Sei EVM contract using `ethers`. You’d replace `proof` and `publicInputs` with outputs from your ZK prover.

```typescript
import { ethers } from 'ethers';

const RPC_URL = process.env.SEI_EVM_RPC!;
const PRIVATE_KEY = process.env.PRIVATE_KEY!;
const CONTRACT = '0xYourContractAddress';

const abi = ['function doAction(bytes proof, uint256[] publicInputs) external'];

async function main() {
  const provider = new ethers.JsonRpcProvider(RPC_URL);
  const wallet = new ethers.Wallet(PRIVATE_KEY, provider);

  const zkApp = new ethers.Contract(CONTRACT, abi, wallet);

  // Produced off-chain by a ZK prover
  const proof = '0x...'; // bytes
  const publicInputs = [
    /* e.g. root, nullifierHash, commitment */
  ];

  const tx = await zkApp.doAction(proof, publicInputs);
  await tx.wait();

  console.log('Submitted proof tx:', tx.hash);
}

main().catch((e) => {
  console.error(e);
  process.exit(1);
});
```

## Key Takeaways

- **What is zero-knowledge proof**: a way to prove a statement is true **without revealing** the secret data that makes it true.
- ZKPs rely on cryptographic guarantees (completeness, soundness, zero-knowledge) to enable privacy and scalable verification.
- On **Sei Network**, ZK-powered applications can leverage **EVM compatibility** for verifier contracts, plus **parallelization** and **~400ms finality** for fast, high-throughput settlement.

## Related Documentation

- [Getting Started](/learn)
- [Token Standards](/learn/dev-token-standards)
- [Staking](/learn/general-staking)
- [Oracles](/learn/oracles)

---

_Have a question that's not answered here? Join our [Discord](https://discord.gg/sei) community._
