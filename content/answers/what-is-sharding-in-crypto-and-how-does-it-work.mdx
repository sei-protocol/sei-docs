---
title: 'What is Sharding in Crypto and How Does It Work?'
description: 'Learn about what is sharding and how it works in blockchain and on Sei Network.'
keywords: ['sei', 'blockchain', 'glossary', 'what', 'sharding', 'crypto', 'and', 'how', 'does', 'work']
---

import { Callout } from 'nextra/components';

# What is Sharding in Crypto and How Does It Work?

## Overview

Sharding is a scalability technique that splits a blockchain’s data and workload across multiple smaller partitions (“shards”) so the network can process transactions in parallel. Instead of every node executing and storing everything, each shard handles a subset of transactions and state, increasing throughput while aiming to preserve decentralization.

In simple terms, **what is sharding**: it’s dividing one blockchain into many coordinated “mini-chains” that together form a single network.

## How It Works

### 1) Partitioning the Network (Shards)

A sharded blockchain divides responsibility across multiple groups of nodes:

- **Transaction sharding**: transactions are routed to specific shards.
- **State sharding**: account/contract state is split across shards.
- **Data sharding**: historical data and availability responsibilities may be partitioned.

Each shard processes its own transactions and maintains its own portion of the ledger/state.

### 2) Parallel Execution

In a traditional (non-sharded) blockchain, every validator typically re-executes all transactions. With sharding:

- Shard A can process its transactions at the same time as Shard B, C, etc.
- Total throughput increases roughly with the number of shards (subject to overhead and bottlenecks).

### 3) Cross-Shard Communication

Many applications require interaction across shards (e.g., sending assets from an account in Shard 1 to a contract in Shard 2). Sharded systems need mechanisms for:

- **Message passing** between shards (often asynchronous).
- **Atomicity guarantees** (ensuring cross-shard actions don’t partially complete).
- **Finality coordination** (deciding when a cross-shard action is considered “done”).

Cross-shard operations introduce complexity and can reduce some of the gains from parallelism if not designed carefully.

### 4) Security Model (Validator Assignment)

To prevent attackers from taking over a single shard, sharded networks typically:

- Randomly assign validators to shards.
- Rotate assignments periodically.
- Use shared security or a beacon/coordination layer to unify consensus and finality.

### 5) Tradeoffs

Sharding improves scalability but comes with tradeoffs:

- **Complexity**: cross-shard messages, receipts, and proofs are non-trivial.
- **Latency**: cross-shard actions may take longer than same-shard transactions.
- **Developer overhead**: apps may need to be “shard-aware,” depending on the design.

## On Sei Network

Sei Network is a high-performance Layer 1 with **EVM compatibility** that achieves scalability through **parallelization** rather than exposing an explicit multi-shard architecture to developers. In practice, this means:

- **Parallel execution**: Sei is built to execute independent transactions concurrently, increasing throughput without requiring application developers to manage cross-shard logic.
- **Fast finality (~400ms)**: transactions can reach finality quickly, improving user experience for trading, games, and other latency-sensitive apps.
- **EVM compatibility**: Solidity smart contracts can run on Sei, benefiting from the network’s performance characteristics without needing special sharding-aware contract patterns.

### Sharding vs. Sei’s Parallelization (Why It Matters)

If you’re evaluating **what is sharding** as a scaling path, it’s helpful to compare it to Sei’s approach:

- Sharding scales by **splitting the chain** into multiple partitions and coordinating across them.
- Sei scales by **keeping one cohesive network** while executing non-conflicting work in parallel, aiming to deliver high throughput with simpler mental models for developers.

For many dApps, Sei’s parallelization provides “shard-like” performance benefits (more concurrent processing) while avoiding common sharding pain points like cross-shard composability constraints.

## Practical Example (EVM Perspective)

Below is a simple Solidity contract that increments a counter. On networks that parallelize execution effectively, many users calling `increment()` on different contracts/accounts can be processed concurrently when transactions don’t conflict on the same state.

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

contract Counter {
    uint256 public count;

    function increment() external {
        count += 1;
    }
}
```

To deploy and interact (example using Foundry). Replace RPC with a Sei EVM endpoint:

```bash
export RPC_URL="https://<sei-evm-rpc-endpoint>"
export PRIVATE_KEY="<your_private_key>"

forge create --rpc-url $RPC_URL --private-key $PRIVATE_KEY src/Counter.sol:Counter
```

## Key Takeaways

- **Sharding** is a method for scaling blockchains by splitting work and state across multiple shards that process transactions in parallel.
- The hardest parts are **cross-shard communication**, **atomic composability**, and **maintaining security** across shards.
- **Sei Network** delivers high throughput via **parallelization** and **~400ms finality** with **EVM compatibility**, providing many scalability benefits without requiring developers to design around explicit shards.

## Related Documentation

- [Getting Started](/learn)
- [Token Standards](/learn/dev-token-standards)
- [Staking](/learn/general-staking)
- [Oracles](/learn/oracles)

---

_Have a question that's not answered here? Join our [Discord](https://discord.gg/sei) community._
