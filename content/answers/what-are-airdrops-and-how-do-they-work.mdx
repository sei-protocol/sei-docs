---
title: 'What Are Airdrops and How Do They Work?'
description: 'Learn about what is airdrops and how it works in blockchain and on Sei Network.'
keywords: ['sei', 'blockchain', 'glossary', 'what', 'airdrops', 'are', 'and', 'how', 'they', 'work']
---

import { Callout } from 'nextra/components';

# What Are Airdrops and How Do They Work?

## Overview

Airdrops are a method of distributing crypto tokens to users’ wallets, typically for free or in exchange for completing simple actions. Projects use airdrops to bootstrap adoption, reward early supporters, decentralize token ownership, or incentivize specific behaviors. If you’re searching for **what is airdrops**, the simplest definition is: token distributions designed to create awareness and participation in a network.

## How It Works

Airdrops generally follow a predictable lifecycle:

### 1) Eligibility rules (“who gets tokens”)

Projects define criteria that determine which wallets qualify, such as:

- **Snapshot-based**: Holding a token, NFT, or meeting an on-chain condition at a specific block/time.
- **Activity-based**: Using a product (swaps, staking, bridging, lending), voting, or providing liquidity.
- **Allowlist-based**: Joining a community, registering interest, KYC (rare for decentralized launches), or being a known contributor.
- **Tiered allocation**: Higher usage or longer participation earns more tokens.

### 2) Snapshot and allocation (“how much each wallet gets”)

A project takes an on-chain **snapshot** (a record of wallet balances/activities at a point in time) and computes allocations using formulas such as:

- Flat amounts per eligible wallet
- Proportional to balances (e.g., token holdings or LP shares)
- Points systems (e.g., volume, days active, number of transactions)

### 3) Distribution mechanism (“how tokens are delivered”)

Common distribution patterns include:

- **Automatic distribution**: Tokens are sent directly to eligible wallets (no action required).
- **Claim-based distribution**: Users must call a **claim** function (paying gas) to receive tokens. This reduces unwanted spam and lets users opt in.
- **Vesting/streaming**: Tokens unlock over time to reduce immediate sell pressure and align long-term incentives.

### 4) Claiming and verification (“prove you’re eligible”)

For claim-based airdrops, projects typically use:

- **Merkle trees**: Off-chain eligibility lists compressed into a Merkle root stored on-chain. Users submit a Merkle proof to claim.
- **Signature-based claims**: A trusted signer (or set of signers) authorizes claims via EIP-712 signatures.

### 5) Anti-abuse protections

Because airdrops can be targeted by bots and “Sybil” attackers (many wallets controlled by one actor), projects often add:

- Minimum activity thresholds (e.g., number of days used, unique interactions)
- Exclusion rules (e.g., obvious farming patterns)
- Caps or diminishing returns
- Optional identity checks (trade-offs with decentralization)

## Common Types of Airdrops

- **Standard promotional airdrops**: Small distributions to drive awareness.
- **Reward airdrops**: For users who provided liquidity, traded, staked, or tested products.
- **Retroactive airdrops**: Reward past users based on historical behavior (popular for DeFi).
- **Holder airdrops**: Reward wallets holding a particular token or NFT.
- **Ecosystem airdrops**: Incentivize usage across multiple apps within an ecosystem.

## Benefits and Risks

### Benefits

- **User acquisition**: Attracts attention and new users quickly.
- **Decentralization**: Spreads ownership to more participants.
- **Incentives**: Rewards early adoption and meaningful usage.
- **Liquidity & network effects**: Can increase activity and ecosystem growth.

### Risks

- **Scams and phishing**: Fake claim sites, malicious approvals, impersonation on social channels.
- **High gas costs (on some chains)**: Claiming can be expensive during congestion.
- **Tax implications**: Many jurisdictions treat airdropped tokens as taxable income upon receipt (consult a tax professional).
- **Market volatility**: Tokens may drop sharply after distribution.

## How to Safely Participate in Airdrops

- Verify links through official project sources (website, verified social accounts, docs).
- Never share seed phrases; avoid signing unknown messages.
- Be cautious with token approvals; review and revoke allowances when needed.
- Prefer a separate wallet for experimental activity.
- Check contract addresses against official announcements.

## On Sei Network

Sei Network is a high-performance Layer 1 with **EVM compatibility**, designed for fast execution and great UX. Airdrops on Sei typically benefit from:

- **Fast finality (~400ms)**, meaning eligibility actions (swaps, staking, interactions) and claim transactions can confirm quickly.
- **Parallelized execution**, enabling higher throughput and smoother claim periods—especially useful when many users claim at once.
- **EVM tooling compatibility**, allowing projects to run familiar airdrop patterns (Merkle claims, vesting contracts) using Solidity and standard Ethereum libraries.

In practice, this means a Sei airdrop can feel closer to a Web2 experience: quick confirmations, reduced congestion issues, and easy integration with EVM wallets and developer tooling.

## Example: Merkle Claim Airdrop Contract (Solidity)

Below is a simplified EVM-style claim contract commonly used for airdrops. It verifies eligibility using a Merkle proof and prevents double-claims.

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {MerkleProof} from "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol";

contract MerkleAirdrop {
    IERC20 public immutable token;
    bytes32 public immutable merkleRoot;

    mapping(address => bool) public hasClaimed;

    event Claimed(address indexed account, uint256 amount);

    constructor(IERC20 _token, bytes32 _merkleRoot) {
        token = _token;
        merkleRoot = _merkleRoot;
    }

    function claim(uint256 amount, bytes32[] calldata proof) external {
        require(!hasClaimed[msg.sender], "Already claimed");

        // leaf = keccak256(abi.encodePacked(account, amount))
        bytes32 leaf = keccak256(bytes.concat(keccak256(abi.encode(msg.sender, amount))));
        require(MerkleProof.verify(proof, merkleRoot, leaf), "Invalid proof");

        hasClaimed[msg.sender] = true;
        require(token.transfer(msg.sender, amount), "Transfer failed");

        emit Claimed(msg.sender, amount);
    }
}
```

## Example: Claim Script (TypeScript)

A typical client flow is: fetch the user’s allocation + Merkle proof from an API, then submit a `claim(amount, proof)` transaction.

```typescript
import { ethers } from 'ethers';

const AIRDROP_ADDRESS = '0xYourAirdropContract';
const ABI = ['function claim(uint256 amount, bytes32[] proof) external', 'function hasClaimed(address) view returns (bool)'];

async function claimAirdrop(rpcUrl: string, privateKey: string, amount: string, proof: string[]) {
  const provider = new ethers.JsonRpcProvider(rpcUrl);
  const wallet = new ethers.Wallet(privateKey, provider);
  const airdrop = new ethers.Contract(AIRDROP_ADDRESS, ABI, wallet);

  const claimed = await airdrop.hasClaimed(wallet.address);
  if (claimed) throw new Error('Already claimed');

  const tx = await airdrop.claim(amount, proof);
  await tx.wait();
  return tx.hash;
}
```

## Key Takeaways

- If you’re asking **what is airdrops**, it’s a token distribution strategy used to reward users and grow networks.
- Airdrops usually rely on snapshots, eligibility rules, and either automatic transfers or on-chain claim contracts.
- On **Sei Network**, airdrops can be smoother due to **parallelization**, **~400ms finality**, and **EVM compatibility** for standard Solidity-based claim mechanisms.

## Related Documentation

- [Getting Started](/learn)
- [Token Standards](/learn/dev-token-standards)
- [Staking](/learn/general-staking)
- [Oracles](/learn/oracles)

---

_Have a question that's not answered here? Join our [Discord](https://discord.gg/sei) community._
