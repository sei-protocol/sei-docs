---
title: 'What is a Smart Contract and How Does It Work?'
description: 'Learn about what is smart contract and how it works in blockchain and on Sei Network.'
keywords: ['sei', 'blockchain', 'evm', 'what', 'smart', 'contract', 'and', 'how', 'does', 'work']
---

import { Callout } from 'nextra/components';

# What is a Smart Contract and How Does It Work?

## Overview

A **smart contract** is a program deployed on a blockchain that automatically executes predefined actions when specific conditions are met. In practical terms, it’s a **tamper-resistant, publicly verifiable** set of rules that can hold and transfer value (tokens) without relying on a centralized intermediary. If you’re asking **what is smart contract**, it’s best understood as “code + state” living on-chain.

## How It Works

### 1) Contract code and state

A smart contract consists of:

- **Code**: the logic (functions, checks, rules).
- **State**: stored data (balances, ownership, configuration, etc.).

Once deployed, the code is typically immutable (or only upgradable via explicit patterns), and the state changes only through valid transactions.

### 2) Transactions trigger execution

Smart contracts don’t run on their own. They execute when a transaction (or another contract call) invokes them:

- A user submits a transaction calling a function (e.g., `transfer`, `swap`, `mint`).
- Network validators execute the contract code deterministically.
- If the call succeeds, state updates are committed to the blockchain; if it reverts, state remains unchanged.

### 3) Deterministic computation and consensus

Every validator (or node) must compute the **same result** from the same inputs. The blockchain’s consensus ensures:

- Only valid state transitions are finalized.
- The resulting state is consistent across all nodes.

### 4) Gas/fees and execution limits (EVM context)

On EVM-based chains, execution costs **gas**, which:

- Prices computation and storage.
- Prevents infinite loops / resource abuse.
- Is paid by the transaction sender as a fee.

### 5) Events and composability

Contracts can:

- Emit **events** to create an indexed on-chain log for apps and analytics.
- Call other contracts, enabling **composability** (e.g., DeFi building blocks).

## Common Smart Contract Use Cases

- **Token issuance** (ERC-20 / ERC-721 / ERC-1155)
- **DeFi** (DEX swaps, lending, staking, derivatives)
- **NFT minting and marketplaces**
- **DAOs and governance** (voting, timelocks, treasuries)
- **Escrow and payments** (conditional release, subscriptions)

## On Sei Network

Sei Network is a high-performance Layer 1 with **EVM compatibility**, meaning developers can deploy and interact with Solidity smart contracts using familiar Ethereum tooling. Sei’s architecture is designed for speed and scalability, leveraging **parallelization** where possible and providing **~400ms finality**, which can significantly improve UX for trading, payments, and other latency-sensitive applications.

Key implications for smart contracts on Sei:

- **EVM-compatible development**: Write contracts in Solidity, use standard ABIs, and integrate with common libraries and frameworks.
- **Fast confirmation UX**: With **~400ms finality**, contract interactions (e.g., swaps, mints, game actions) can feel near-instant compared to slower finality chains.
- **Parallelized execution potential**: Sei is built to increase throughput via parallelization, enabling higher performance for workloads with independent state access patterns.

## Example: A Simple Solidity Smart Contract (EVM)

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

contract Counter {
    uint256 public number;

    event NumberChanged(uint256 newNumber, address indexed caller);

    function setNumber(uint256 newNumber) external {
        number = newNumber;
        emit NumberChanged(newNumber, msg.sender);
    }

    function increment() external {
        number += 1;
        emit NumberChanged(number, msg.sender);
    }
}
```

What’s happening here:

- `number` is **on-chain state** stored in the contract.
- `setNumber` and `increment` are **transactions** that update state.
- `NumberChanged` is an **event** that frontends/indexers can watch.

## Deploying to Sei EVM (Example)

Using Foundry (one common workflow), you can deploy to Sei’s EVM JSON-RPC endpoint.

```bash
# Set environment variables
export RPC_URL="https://<sei-evm-rpc-endpoint>"
export PRIVATE_KEY="<your_private_key>"

# Deploy (example assumes a Foundry script or direct create)
forge create --rpc-url "$RPC_URL" --private-key "$PRIVATE_KEY" src/Counter.sol:Counter
```

Then call a function:

```bash
cast send <COUNTER_ADDRESS> "increment()" --rpc-url "$RPC_URL" --private-key "$PRIVATE_KEY"
```

## Security Considerations (Best Practices)

Smart contracts are powerful but unforgiving—bugs can become irreversible once deployed. Common best practices include:

- Use audited libraries (e.g., OpenZeppelin).
- Add access controls (e.g., `onlyOwner`) where needed.
- Prefer pull over push payments to reduce reentrancy risk.
- Write tests (unit + fuzz + integration) and run static analysis.
- Consider upgradeability carefully (transparent/UUPS proxies, timelocks, governance).

## Summary

If you’re looking for a practical answer to **what is smart contract**, it’s an on-chain program that enforces rules and executes transactions automatically, with results verified by network consensus. On **Sei Network**, smart contracts benefit from **EVM compatibility**, **parallelization-focused performance**, and **~400ms finality**, making them well-suited for high-throughput, real-time applications.

## Related Documentation

- [EVM Overview](/evm)
- [Networks & RPC](/evm/networks)
- [Deploy with Hardhat](/evm/evm-hardhat)
- [Deploy with Foundry](/evm/evm-foundry)

---

_Have a question that's not answered here? Join our [Discord](https://discord.gg/sei) community._
