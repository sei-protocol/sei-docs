# Sei V2 EVM Smart Contract Development with Hardhat & OpenZeppelin

This tutorial will guide you through setting up Hardhat for Sei V2 EVM development and using OpenZeppelin contracts to build secure, standardized smart contracts. We'll cover environment setup, contract creation, deployment, and show how to leverage OpenZeppelin's pre-built components.

## Table of Contents

- [Prerequisites](#prerequisites)
- [Setting Up Your Development Environment](#setting-up-your-development-environment)
- [Configuring Hardhat for Sei V2 EVM](#configuring-hardhat-for-sei-v2-evm)
- [Using OpenZeppelin Contracts](#using-openzeppelin-contracts)
- [Creating and Deploying an ERC20 Token](#creating-and-deploying-an-erc20-token)
- [Creating and Deploying an ERC721 NFT](#creating-and-deploying-an-erc721-nft)
- [Implementing an Upgradeable Smart Contract](#implementing-an-upgradeable-smart-contract)
- [Testing Your Smart Contracts](#testing-your-smart-contracts)
- [Deploying to Sei Testnet and Mainnet](#deploying-to-sei-testnet-and-mainnet)

## Prerequisites

Before we begin, ensure you have the following installed:

- [Node.js](https://nodejs.org/) (v16.0.0 or later)
- [npm](https://www.npmjs.com/) (v7.0.0 or later) or [yarn](https://yarnpkg.com/)
- A code editor (VS Code recommended)
- Basic knowledge of Solidity and JavaScript

## Setting Up Your Development Environment

Let's create a new project and set up Hardhat:

```bash copy
# Create a new directory for your project
mkdir sei-hardhat-project
cd sei-hardhat-project

# Initialize a new npm project
npm init -y

# Install Hardhat and necessary dependencies
npm install --save-dev hardhat @nomicfoundation/hardhat-toolbox @openzeppelin/contracts
```

After installation, initialize a new Hardhat project:

```bash copy
npx hardhat init
```

When prompted, select "Create a JavaScript project" and follow the setup instructions.

## Configuring Hardhat for Sei V2 EVM

Next, we'll need to configure Hardhat to work with the Sei V2 EVM. Update your `hardhat.config.js` file:

```javascript copy
require('@nomicfoundation/hardhat-toolbox');
require('dotenv').config();

// Load environment variables
const PRIVATE_KEY = process.env.PRIVATE_KEY || '0x0000000000000000000000000000000000000000000000000000000000000000';
const SEI_API_KEY = process.env.SEI_API_KEY || '';

/** @type import('hardhat/config').HardhatUserConfig */
module.exports = {
  solidity: {
    version: '0.8.20',
    settings: {
      optimizer: {
        enabled: true,
        runs: 200
      }
    }
  },
  networks: {
    // Sei testnet configuration
    seitestnet: {
      url: 'https://evm-rpc.testnet.sei.io',
      accounts: [PRIVATE_KEY],
      chainId: 713715, // Sei testnet chain ID
      gasPrice: 2000000000 // 2 gwei = 2 nsei
    },
    // Sei mainnet configuration
    seimainnet: {
      url: 'https://evm-rpc.mainnet.sei.io',
      accounts: [PRIVATE_KEY],
      chainId: 1868, // Sei mainnet chain ID
      gasPrice: 2000000000 // 2 gwei = 2 nsei
    },
    // Local development with Hardhat Network
    hardhat: {
      chainId: 31337
    }
  },
  etherscan: {
    apiKey: {
      seitestnet: SEI_API_KEY,
      seimainnet: SEI_API_KEY
    },
    customChains: [
      {
        network: 'seitestnet',
        chainId: 713715,
        urls: {
          apiURL: 'https://api-testnet.sei.io/api',
          browserURL: 'https://explorer-testnet.sei.io'
        }
      },
      {
        network: 'seimainnet',
        chainId: 1868,
        urls: {
          apiURL: 'https://api.sei.io/api',
          browserURL: 'https://explorer.sei.io'
        }
      }
    ]
  },
  paths: {
    sources: './contracts',
    tests: './test',
    cache: './cache',
    artifacts: './artifacts'
  },
  mocha: {
    timeout: 40000
  }
};
```

Create a `.env` file in your project root to store your private key and API key:

```bash copy
PRIVATE_KEY=your_private_key_here
SEI_API_KEY=your_sei_scan_api_key_here
```

Add `.env` to your `.gitignore` file to prevent committing sensitive information.

## Using OpenZeppelin Contracts

OpenZeppelin provides a library of secure, tested smart contract components that you can use to build your applications. First, let's install the OpenZeppelin Contracts package:

```bash copy
npm install @openzeppelin/contracts
```

For upgradeable contracts, also install:

```bash copy
npm install @openzeppelin/contracts-upgradeable @openzeppelin/hardhat-upgrades
```

Update your `hardhat.config.js` to import the upgrades plugin:

```javascript copy
require('@nomicfoundation/hardhat-toolbox');
require('@openzeppelin/hardhat-upgrades');
require('dotenv').config();

// Rest of your configuration...
```

## Creating and Deploying an ERC20 Token

Let's create a simple ERC20 token using OpenZeppelin contracts. Create a new file in the `contracts` directory called `SeiToken.sol`:

```solidity copy
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

contract SeiToken is ERC20, Ownable {
    constructor(address initialOwner)
        ERC20("Sei Token", "SEI")
        Ownable(initialOwner)
    {
        // Mint 1 million tokens to the contract deployer (with 18 decimals)
        _mint(msg.sender, 1000000 * 10 ** decimals());
    }

    // Function to mint new tokens (only owner)
    function mint(address to, uint256 amount) public onlyOwner {
        _mint(to, amount);
    }

    // Function to burn tokens
    function burn(uint256 amount) public {
        _burn(msg.sender, amount);
    }
}
```

Now, create a deployment script in the `scripts` directory called `deploy-sei-token.js`:

```javascript copy
const { ethers } = require('hardhat');

async function main() {
  const [deployer] = await ethers.getSigners();
  console.log('Deploying contracts with the account:', deployer.address);

  // Get the contract factory
  const SeiToken = await ethers.getContractFactory('SeiToken');

  // Deploy the contract
  const seiToken = await SeiToken.deploy(deployer.address);
  await seiToken.waitForDeployment();

  console.log('SeiToken deployed to:', await seiToken.getAddress());
}

main()
  .then(() => process.exit(0))
  .catch((error) => {
    console.error(error);
    process.exit(1);
  });
```

To deploy the token to the Sei testnet:

```bash copy
npx hardhat run scripts/deploy-sei-token.js --network seitestnet
```

## Creating and Deploying an ERC721 NFT

Now, let's create an ERC721 NFT contract. Create a new file `SeiNFT.sol` in the `contracts` directory:

```solidity copy
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/Counters.sol";

contract SeiNFT is ERC721URIStorage, Ownable {
    using Counters for Counters.Counter;
    Counters.Counter private _tokenIds;

    // Base URI for metadata
    string private _baseTokenURI;

    constructor(address initialOwner, string memory baseTokenURI)
        ERC721("Sei NFT Collection", "SEINFT")
        Ownable(initialOwner)
    {
        _baseTokenURI = baseTokenURI;
    }

    // Function to mint new NFTs
    function mintNFT(address recipient, string memory tokenURI) public onlyOwner returns (uint256) {
        _tokenIds.increment();
        uint256 newItemId = _tokenIds.current();

        _mint(recipient, newItemId);
        _setTokenURI(newItemId, tokenURI);

        return newItemId;
    }

    // Function to update the base URI (only owner)
    function setBaseURI(string memory baseTokenURI) public onlyOwner {
        _baseTokenURI = baseTokenURI;
    }

    // Override the baseURI function
    function _baseURI() internal view override returns (string memory) {
        return _baseTokenURI;
    }
}
```

Create a deployment script `deploy-sei-nft.js`:

```javascript copy
const { ethers } = require('hardhat');

async function main() {
  const [deployer] = await ethers.getSigners();
  console.log('Deploying contracts with the account:', deployer.address);

  // Base URI for your NFT metadata
  const baseURI = 'https://your-metadata-server.com/metadata/';

  // Get the contract factory
  const SeiNFT = await ethers.getContractFactory('SeiNFT');

  // Deploy the contract
  const seiNFT = await SeiNFT.deploy(deployer.address, baseURI);
  await seiNFT.waitForDeployment();

  console.log('SeiNFT deployed to:', await seiNFT.getAddress());

  // Mint an example NFT
  console.log('Minting an example NFT...');
  const mintTx = await seiNFT.mintNFT(deployer.address, '1.json');
  await mintTx.wait();
  console.log('NFT minted with ID: 1');
}

main()
  .then(() => process.exit(0))
  .catch((error) => {
    console.error(error);
    process.exit(1);
  });
```

Deploy the NFT contract to the Sei testnet:

```bash copy
npx hardhat run scripts/deploy-sei-nft.js --network seitestnet
```

## Implementing an Upgradeable Smart Contract

Upgradeable contracts are essential for complex applications that may need patches or feature additions in the future. We'll create an upgradeable ERC1155 contract using OpenZeppelin's upgradeable contracts.

First, create `SeiMultiToken.sol` in the `contracts` directory:

```solidity copy
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts-upgradeable/token/ERC1155/ERC1155Upgradeable.sol";
import "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";

contract SeiMultiToken is Initializable, ERC1155Upgradeable, OwnableUpgradeable, UUPSUpgradeable {
    // Token type IDs
    uint256 public constant GOLD = 0;
    uint256 public constant SILVER = 1;
    uint256 public constant BRONZE = 2;

    // Version tracking for upgrades
    string public version;

    /// @custom:oz-upgrades-unsafe-allow constructor
    constructor() {
        _disableInitializers();
    }

    function initialize(address initialOwner) public initializer {
        __ERC1155_init("https://your-metadata-server.com/metadata/{id}.json");
        __Ownable_init(initialOwner);
        __UUPSUpgradeable_init();

        version = "1.0";

        // Mint some initial tokens to the owner
        _mint(initialOwner, GOLD, 100, "");
        _mint(initialOwner, SILVER, 500, "");
        _mint(initialOwner, BRONZE, 1000, "");
    }

    // Function to mint new tokens (only owner)
    function mint(address to, uint256 id, uint256 amount) public onlyOwner {
        _mint(to, id, amount, "");
    }

    // Function to mint batches of tokens (only owner)
    function mintBatch(address to, uint256[] memory ids, uint256[] memory amounts) public onlyOwner {
        _mintBatch(to, ids, amounts, "");
    }

    // Authorization for upgrades
    function _authorizeUpgrade(address newImplementation) internal override onlyOwner {}
}
```

Next, create a deployment script `deploy-multi-token.js`:

```javascript copy
const { ethers, upgrades } = require('hardhat');

async function main() {
  const [deployer] = await ethers.getSigners();
  console.log('Deploying contracts with the account:', deployer.address);

  // Get the contract factory
  const SeiMultiToken = await ethers.getContractFactory('SeiMultiToken');

  // Deploy as upgradeable contract
  console.log('Deploying SeiMultiToken...');
  const seiMultiToken = await upgrades.deployProxy(SeiMultiToken, [deployer.address], { initializer: 'initialize', kind: 'uups' });

  await seiMultiToken.waitForDeployment();
  console.log('SeiMultiToken deployed to:', await seiMultiToken.getAddress());
}

main()
  .then(() => process.exit(0))
  .catch((error) => {
    console.error(error);
    process.exit(1);
  });
```

To demonstrate upgrading, let's create a new version of the contract. Create `SeiMultiTokenV2.sol`:

```solidity copy
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "./SeiMultiToken.sol";

contract SeiMultiTokenV2 is SeiMultiToken {
    // New feature: A mapping to store token names
    mapping(uint256 => string) public tokenNames;

    // Function to set a token name (only owner)
    function setTokenName(uint256 id, string memory name) public onlyOwner {
        tokenNames[id] = name;
    }

    // Function to update the version
    function updateVersion() external onlyOwner {
        version = "2.0";
    }

    // New function to burn tokens
    function burn(address from, uint256 id, uint256 value) public {
        require(from == msg.sender || isApprovedForAll(from, msg.sender),
                "ERC1155: caller is not owner nor approved");
        _burn(from, id, value);
    }
}
```

Now create an upgrade script `upgrade-multi-token.js`:

```javascript copy
const { ethers, upgrades } = require('hardhat');

async function main() {
  const [deployer] = await ethers.getSigners();
  console.log('Upgrading with the account:', deployer.address);

  // Address of the deployed proxy
  const proxyAddress = 'YOUR_DEPLOYED_PROXY_ADDRESS';

  // Get the contract factory for V2
  const SeiMultiTokenV2 = await ethers.getContractFactory('SeiMultiTokenV2');

  // Upgrade the contract
  console.log('Upgrading SeiMultiToken...');
  const upgraded = await upgrades.upgradeProxy(proxyAddress, SeiMultiTokenV2);

  console.log('SeiMultiToken upgraded. Address:', await upgraded.getAddress());

  // Update the version
  const updateTx = await upgraded.updateVersion();
  await updateTx.wait();

  // Set some token names
  await upgraded.setTokenName(0, 'GOLD');
  await upgraded.setTokenName(1, 'SILVER');
  await upgraded.setTokenName(2, 'BRONZE');

  console.log('Version updated and token names set');
}

main()
  .then(() => process.exit(0))
  .catch((error) => {
    console.error(error);
    process.exit(1);
  });
```

## Testing Your Smart Contracts

Hardhat makes it easy to test your contracts before deploying them. Create a test file `test/sei-token-test.js`:

```javascript copy
const { expect } = require('chai');
const { ethers } = require('hardhat');

describe('SeiToken', function () {
  let SeiToken;
  let seiToken;
  let owner;
  let addr1;
  let addr2;

  beforeEach(async function () {
    // Get signers
    [owner, addr1, addr2] = await ethers.getSigners();

    // Deploy the token
    SeiToken = await ethers.getContractFactory('SeiToken');
    seiToken = await SeiToken.deploy(owner.address);
  });

  describe('Deployment', function () {
    it('Should set the right owner', async function () {
      expect(await seiToken.owner()).to.equal(owner.address);
    });

    it('Should assign the total supply of tokens to the owner', async function () {
      const ownerBalance = await seiToken.balanceOf(owner.address);
      const totalSupply = await seiToken.totalSupply();
      expect(totalSupply).to.equal(ownerBalance);
    });

    it('Should have correct name and symbol', async function () {
      expect(await seiToken.name()).to.equal('Sei Token');
      expect(await seiToken.symbol()).to.equal('SEI');
    });
  });

  describe('Transactions', function () {
    it('Should transfer tokens between accounts', async function () {
      // Transfer 50 tokens from owner to addr1
      await seiToken.transfer(addr1.address, 50);
      expect(await seiToken.balanceOf(addr1.address)).to.equal(50);

      // Transfer 50 tokens from addr1 to addr2
      await seiToken.connect(addr1).transfer(addr2.address, 50);
      expect(await seiToken.balanceOf(addr2.address)).to.equal(50);
    });

    it("Should fail if sender doesn't have enough tokens", async function () {
      const initialOwnerBalance = await seiToken.balanceOf(owner.address);

      // Try to send 1 token from addr1 (0 tokens) to owner
      await expect(seiToken.connect(addr1).transfer(owner.address, 1)).to.be.reverted;

      // Owner balance shouldn't change
      expect(await seiToken.balanceOf(owner.address)).to.equal(initialOwnerBalance);
    });
  });

  describe('Minting', function () {
    it('Should allow owner to mint new tokens', async function () {
      await seiToken.mint(addr1.address, 1000);
      expect(await seiToken.balanceOf(addr1.address)).to.equal(1000);
    });

    it('Should not allow non-owners to mint', async function () {
      await expect(seiToken.connect(addr1).mint(addr1.address, 1000)).to.be.reverted;
    });
  });
});
```

Run your tests with:

```bash copy
npx hardhat test
```

## Deploying to Sei Testnet and Mainnet

Once you've tested your contracts, you can deploy them to the Sei testnet or mainnet. To deploy, you'll need:

1. SEI tokens in your wallet for gas fees
2. Your private key in the `.env` file

Deploy to the testnet:

```bash copy
npx hardhat run scripts/deploy-sei-token.js --network seitestnet
```

Deploy to the mainnet (only when you're ready for production):

```bash copy
npx hardhat run scripts/deploy-sei-token.js --network seimainnet
```
